Option Explicit
'============================================================
' modProcess
' 概要: パイプラインの切替、Import/Processのワークフロー、Masterテーブルへの貼り付け、エンコード選択等
'============================================================


'=== 既定行数にマスターの表サイズを戻す（B4セル：行数設定 / 空なら20000） ===
' 概要: Master_* テーブルのサイズを初期化（必要行/列の確保・不要領域の削除）
' 備考: Process 前に安全なサイズへ調整

Private Sub ResetMasterSize(masterLo As ListObject)
    On Error Resume Next
    If masterLo Is Nothing Then Exit Sub
    Dim ws As Worksheet: Set ws = masterLo.Parent
    Dim reserve As Long
    reserve = CLng(Val(ws.Range("B4").Value)) ' 任意セルに既定行数を置く運用。空なら下で既定値に
    If reserve <= 0 Then reserve = 20000

    Dim cols As Long: cols = masterLo.ListColumns.Count
    Dim newRg As Range
    Set newRg = masterLo.HeaderRowRange.Resize(reserve + 1, cols)
    masterLo.Resize newRg
    If Not masterLo.DataBodyRange Is Nothing Then masterLo.DataBodyRange.ClearContents
    On Error GoTo 0
End Sub


'=== 高速クリア：テーブルのデータ部を空に（列構成は維持） ===
' 概要: 指定 ListObject のデータ行を高速でクリアします（ヘッダ保持）
' 引数:
'   lo As ListObject  … クリア対象のテーブル

Private Sub FastClearTable(lo As ListObject)
    If lo Is Nothing Then Exit Sub
    If lo.DataBodyRange Is Nothing Then
        ' 既に0行
        Exit Sub
    End If
    ' 行がある場合は全部削除（列は温存）
    lo.DataBodyRange.Delete xlShiftUp
End Sub


'==============================
' パイプライン切替（Main / List）
'==============================
' 概要: Main パイプライン用のマッピング/マスター/エクスポート設定
' 備考: Mapping/Main を使用（1対多は禁止）
' 備考: ログに 'Switched pipeline: Main' を出力

Public Sub UsePipelineMain()
    CurrentMappingTableName = "Mapping_Main"
    CurrentMasterTableName = "Master_Main"
    CurrentExportBaseName = "main"
    AllowOneToMany = False
    WriteLog "INFO", "Switched pipeline: Main"
End Sub
' 概要: List パイプライン用のマッピング/マスター/エクスポート設定を適用
' 備考: Mapping/List を使用（1対多を許可）
' 備考: ログに 'Switched pipeline: List' を出力

Public Sub UsePipelineList()
    CurrentMappingTableName = "Mapping_List"
    CurrentMasterTableName = "Master_List"
    CurrentExportBaseName = "list"
    AllowOneToMany = True
    WriteLog "INFO", "Switched pipeline: List"
End Sub

'==============================
' エンコード選択
'==============================

Public Sub ChooseEncoding()
    Dim s As String
    s = InputBox( _
        "読み込み・書き出しのエンコードを指定してください。" & vbCrLf & _
        "AUTO / UTF-8 / Shift_JIS / UTF-16LE", _
        "Encoding Mode", IIf(Len(CurrentEncodingMode) = 0, "AUTO", CurrentEncodingMode))
    If s = "False" Then Exit Sub
    s = UCase$(Trim$(s))
    Select Case s
        Case "AUTO", "UTF-8", "UTF8": CurrentEncodingMode = IIf(s = "UTF8", "UTF-8", s)
        Case "SHIFT_JIS", "SJIS", "CP932": CurrentEncodingMode = "SHIFT_JIS"
        Case "UTF-16LE", "UTF16LE", "UNICODE": CurrentEncodingMode = "UTF-16LE"
        Case Else: CurrentEncodingMode = "AUTO"
    End Select
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    WriteLog "INFO", "Encoding set: " & CurrentEncodingMode
    MsgBox "Encoding Mode: " & CurrentEncodingMode, vbInformation
End Sub

'==============================
' Import：CSV読込→キー索引→JOIN（無加工）→Master貼付
'==============================

Public Sub ImportFiles(pipeLine)
    '例外発生時EHへジャンプし終了
    On Error GoTo EH
    '開始時刻の記録
    Dim tStart As Date: tStart = Now
    '読み込み時の文字コード設定
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    
    '読み込みパイプラインの選択
    If pipeLine = "Main" Then  ' Main読み込み時
        UsePipelineMain
    ElseIf pipeLine = "List" Then  ' List読み込み時
        UsePipelineList
    End If
    
    'Mappingシートの読み取り
    Dim ok As Boolean
    'Mapping読み取り処理（modMappingHelper）
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        MsgBox "Mapping の読み取りに失敗しました。", vbCritical
        Exit Sub
    End If
    
    'インポート対象フォルダの絶対パスを作成
    Dim importPath As String: importPath = ThisWorkbook.Path & "\" & IMPORT_FOLDER & "\"
    EnsureFolder ThisWorkbook.Path & "\" & LOG_FOLDER & "\"
    Set TableData = CreateObject("Scripting.Dictionary")  ' CSV読み込み後の全テーブルデータを保持する Dictionary を初期化
    If Not LoadAllCsv(importPath, Map_TblNames, TableData) Then Exit Sub
    
    'マッピング／設定に基づくフィルターが存在すれば適用（存在しない場合は無処理）
    ApplyFiltersIfExist
    
    'JOINに必要なキーのインデックスを構築
    BuildKeyIndexes
    m_baseTblName = PickBaseTableName(Map_TblNames, Map_SrcCols, Map_IsKey)  ' JOINのベースとなるテーブル名を選定
    If Len(m_baseTblName) = 0 And (Not Not Map_TblNames) <> 0 Then m_baseTblName = Map_TblNames(0)  ' ベーステーブル名が決まらない場合フォールバック
     
    '無加工JOIN
    IgnoreModeOnImport = True
    RawJoined = BuildJoinedRaw(m_baseTblName)
    IgnoreModeOnImport = False
    
    HasRaw = True: IsProcessed = False  ' 内部状態フラグの更新
    
    '貼り付け先Masterテーブルを取得
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    
    '無加工JOIN結果をMasterテーブルへ貼り付け
    PasteToMasterByTable masterLo, RawJoined
    
    '完了通知
    MsgBox "ファイルインポート完了（無加工をMasterへ反映）", vbInformation
    Exit Sub
EH:
    MsgBox "ImportFilesでエラー: " & Err.Description, vbCritical
End Sub


'==============================
' Process：加工適用 → Masterへ
'==============================

Public Sub ProcessData(pipeLine)
    '例外発生時EHへジャンプし終了
    On Error GoTo EH
    '開始時刻の記録
    Dim tStart As Date: tStart = Now
    
    'インポート処理未実施の場合はエラー終了
    If Not HasRaw Then
        MsgBox "先に『ファイルインポート』を実行してください。", vbExclamation
        Exit Sub
    End If
    
    '読み込み時の文字コード設定
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    
    '読み込みパイプラインの選択
    If pipeLine = "Main" Then
        UsePipelineMain
    ElseIf pipeLine = "List" Then
        UsePipelineList
    End If
    
    'Mappingシートの読み取り
    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then
        WriteLog "ERROR", "Mapping read failed in ProcessData"
        MsgBox "Mapping の読み取りに失敗しました。", vbCritical
        Exit Sub
    End If
    
    ' 無加工データ(RawJoined)に対してスマート変換を適用
    ' - 例: 型変換、正規化、列追加・再計算、条件フィルタ、列順序変更など
    ' - 戻り値は「加工済み配列」
    Dim procArr As Variant
    procArr = ApplyTransformSmart(RawJoined)
    
    ' 出力先Masterのテーブルを取得
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    
    ' 加工済み配列をMasterへ貼り付け
    PasteToMasterByTable masterLo, procArr
    IsProcessed = True  ' 加工完了フラグ
    
    ' ログ出力(行数/列数/経過時間)
    ' - UBound(procArr, 1): 行数上限インデックス
    ' - UBound(procArr, 2): 列数上限インデックス
    ' - Now - tStart      : 経過時間(TimeSpan)
    WriteLog "INFO", "ProcessData: done / rows=" & UBound(procArr, 1) & " / cols=" & UBound(procArr, 2) & " / elapsed=" & Format(Now - tStart, "hh:nn:ss")
    
    ' 完了通知
    MsgBox "データ加工完了（Masterへ反映）", vbInformation
    Exit Sub
EH:
    WriteLog "ERROR", "ProcessData error: " & Err.Number & " " & Err.Description
    MsgBox "ProcessDataでエラー: " & Err.Description, vbCritical
End Sub


'==============================
' Clear：Masterクリア＆中間データ破棄
'==============================

Public Sub ClearData()
    Dim prevCalc As XlCalculation
    Dim prevEvt As Boolean, prevUpd As Boolean
    prevCalc = Application.Calculation
    prevEvt = Application.EnableEvents
    prevUpd = Application.ScreenUpdating
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.ScreenUpdating = False

    On Error GoTo FIN

    Dim lo As ListObject

    Set lo = GetListObjectByName("Master_Main")
    If Not lo Is Nothing Then FastClearTable lo

    Set lo = GetListObjectByName("Master_List")
    If Not lo Is Nothing Then FastClearTable lo

    ' 中間データのクリア
    On Error Resume Next
    Set TableData = Nothing
    Set KeyIndexSingle = Nothing
    Set KeyIndexMulti = Nothing
    Erase Map_OutCols: Erase Map_DataType
    Erase Map_IsKey: Erase Map_Mode: Erase Map_Def
    Erase Map_IsKey: Erase Map_TblNames
    Erase Map_SrcCols
    On Error GoTo 0

    WriteLog "INFO", "ClearData: done (fast)"
    MsgBox "データクリアを実行しました。"

FIN:
    Application.Calculation = prevCalc
    Application.EnableEvents = prevEvt
    Application.ScreenUpdating = prevUpd
End Sub


'==============================
' Masterへ貼付（行数だけ合わせて一括代入）
'==============================
' 概要: テーブル名→対象 Master_* へ配列を貼り付け
' 引数:
'   tblName As String  … 貼付対象テーブル名
'   arr As Variant  … 貼付する2次元配列（ヘッダ付）

Public Sub PasteToMasterByTable(masterTbl As ListObject, dataArr As Variant)
    Dim rows As Long, cols As Long
    rows = UBound(dataArr, 1): cols = UBound(dataArr, 2)
    If masterTbl.ListColumns.Count <> cols Then
        WriteLog "ERROR", "Master columns mismatch. Master=" & masterTbl.ListColumns.Count & " Mapping=" & cols
        MsgBox "Masterテーブルの列数がMappingの出力列数と一致しません。", vbCritical
        Exit Sub
    End If
    Dim newRange As Range
    Set newRange = masterTbl.HeaderRowRange.Resize(rows + 1, cols)
    masterTbl.Resize newRange
    masterTbl.DataBodyRange.Value = dataArr
End Sub


'=== Runner: Import (PerfGuardから呼ばれる) ===
' 概要: CSV 入力→前処理→マスター準備まで実行
' 引数:
'   pipeLine As String  … パイプライン名（"Main"|"List"）
' 備考: ImportFiles を呼び出し、EndProgress で終了

Public Sub Run_Import(ByVal pipeLine As String)
    On Error GoTo EH
    Pulse "インポート準備中"
    ImportFiles pipeLine
    EndProgress "インポート完了"
    Exit Sub
EH:
    EndProgress "インポート中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub


'=== Runner: Process (PerfGuardから呼ばれる) ===
' 概要: （Import 済みデータに対して）マッピング→JOIN/CONCAT→型変換→フィルタ適用→Master_* へ貼付、までの本処理を実行
' 引数:
'   pipeLine As String  … パイプライン名（"Main"|"List"）
' 備考: 途中で進捗更新（Pulse）、最終的にEndProgress

Public Sub Run_Process(ByVal pipeLine As String)
    On Error GoTo EH
    Pulse "加工準備中"
    ProcessData pipeLine
    EndProgress "加工完了"
    Exit Sub
EH:
    EndProgress "加工中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub
