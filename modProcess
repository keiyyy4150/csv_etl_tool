Option Explicit
'============================================================
' modProcess
' 概要: Import/Process のワークフローと Master 貼付（JoinKeyのImport適用を含む）
'============================================================

'=== グローバル状態（既存） ===
Public CurrentMappingTableName As String
Public CurrentMasterTableName As String
Public CurrentExportBaseName As String
Public AllowOneToMany As Boolean
Public CurrentEncodingMode As String
Public HasRaw As Boolean, IsProcessed As Boolean
Public m_baseTblName As String
Public RawJoined As Variant
Public m_baseRowIdx() As Long
Public IgnoreModeOnImport As Boolean

'=== 外部参照（既存モジュールの公開関数想定） ===
Declare PtrSafe Sub WriteLog Lib "kernel32" Alias "OutputDebugStringA" (ByVal lpOutputString As String)
' ↑ 上のDeclareはお使いのプロジェクトの実装に合わせて適宜置換してください（ここではデバッグ用途）

'==============================
' パイプライン切替
'==============================
Public Sub UsePipelineMain()
    CurrentMappingTableName = "Mapping_Main"
    CurrentMasterTableName = "Master_Main"
    CurrentExportBaseName = "main"
    AllowOneToMany = False
End Sub

Public Sub UsePipelineList()
    CurrentMappingTableName = "Mapping_List"
    CurrentMasterTableName = "Master_List"
    CurrentExportBaseName = "list"
    AllowOneToMany = True
End Sub

'==============================
' Import：CSV→JOIN（無加工）→JoinKey適用→Master
'==============================
Public Sub ImportFiles(pipeLine As String)
    On Error GoTo EH

    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If pipeLine = "Main" Then
        UsePipelineMain
    ElseIf pipeLine = "List" Then
        UsePipelineList
    End If

    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then Exit Sub

    ' CSVロード（外部: LoadAllCsv を想定）
    Dim importPath As String: importPath = ThisWorkbook.Path & "\" & "import" & "\"
    EnsureFolder ThisWorkbook.Path & "\" & "log" & "\"
    Set TableData = CreateObject("Scripting.Dictionary")
    If Not LoadAllCsv(importPath, Map_TblNames, TableData) Then Exit Sub

    ' 任意のフィルタ
    ApplyFiltersIfExist

    ' キー索引
    BuildKeyIndexes
    m_baseTblName = PickBaseTableName(Map_TblNames, Map_SrcCols, Map_IsKey)
    If Len(m_baseTblName) = 0 And (Not Not Map_TblNames) <> 0 Then m_baseTblName = Map_TblNames(LBound(Map_TblNames))

    ' 無加工JOIN
    IgnoreModeOnImport = True
    RawJoined = BuildJoinedRaw(m_baseTblName)
    IgnoreModeOnImport = False

    ' ★ Import時に JoinKey を適用して列ごとに LEFT JOIN 値で上書き
    ApplyJoinKeysOnImport RawJoined, m_baseTblName

    HasRaw = True: IsProcessed = False

    ' Masterへ貼付
    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If
    PasteToMasterByTable masterLo, RawJoined
    MsgBox "ファイルインポート完了（JoinKey反映済み）", vbInformation
    Exit Sub
EH:
    MsgBox "ImportFiles エラー: " & Err.Description, vbCritical
End Sub

'==============================
' Process：加工 → Master
'==============================
Public Sub ProcessData(pipeLine As String)
    On Error GoTo EH
    If Not HasRaw Then
        MsgBox "先に『ファイルインポート』を実行してください。", vbExclamation
        Exit Sub
    End If
    If Len(CurrentEncodingMode) = 0 Then CurrentEncodingMode = "AUTO"
    If pipeLine = "Main" Then
        UsePipelineMain
    ElseIf pipeLine = "List" Then
        UsePipelineList
    End If

    Dim ok As Boolean
    ok = ReadMappingFromTableName(CurrentMappingTableName)
    If Not ok Then Exit Sub

    Dim procArr As Variant
    procArr = ApplyTransformSmart(RawJoined)

    Dim masterLo As ListObject
    Set masterLo = GetListObjectByName(CurrentMasterTableName)
    If masterLo Is Nothing Then
        MsgBox "Masterテーブルが見つかりません: " & CurrentMasterTableName, vbCritical
        Exit Sub
    End If

    PasteToMasterByTable masterLo, procArr
    IsProcessed = True
    MsgBox "データ加工完了", vbInformation
    Exit Sub
EH:
    MsgBox "ProcessData エラー: " & Err.Description, vbCritical
End Sub

'==============================
' JoinKey適用（Import直後のRawJoinedに上書き）
'==============================
Private Sub ApplyJoinKeysOnImport(ByRef Raw As Variant, ByVal baseTableName As String)
    On Error GoTo EH
    If (Not Not Map_JoinSpec) = 0 Then Exit Sub
    If TableData Is Nothing Then Exit Sub
    If Not TableData.Exists(baseTableName) Then Exit Sub

    Dim baseArr As Variant: baseArr = TableData(baseTableName)
    Dim baseHdrIx As Object: Set baseHdrIx = CreateObject("Scripting.Dictionary")
    Dim j As Long
    For j = 1 To UBound(baseArr, 2)
        baseHdrIx(CStr(baseArr(1, j))) = j
    Next

    Dim outHdrIx As Object: Set outHdrIx = CreateObject("Scripting.Dictionary")
    For j = 1 To UBound(Raw, 2)
        outHdrIx(CStr(Raw(1, j))) = j
    Next

    Dim r As Long
    For r = LBound(Map_JoinSpec) To UBound(Map_JoinSpec)
        Dim spec As String: spec = Map_JoinSpec(r)
        If Len(spec) = 0 Then GoTo CONT_R

        Dim refTbl As String: refTbl = ResolveReferencedTableName_ByRow(r)
        Dim refValCol As String: refValCol = ResolveReferencedValueColumn_ByRow(r)
        If Len(refTbl) = 0 Or Len(refValCol) = 0 Then GoTo CONT_R
        If Not TableData.Exists(refTbl) Then GoTo CONT_R

        Dim js As TJoinSpec: js = ParseJoinSpec(spec)
        If Len(js.tableName) = 0 Then GoTo CONT_R
        If StrComp(js.tableName, refTbl, vbTextCompare) <> 0 Then GoTo CONT_R

        Dim idx As Object: Set idx = GetOrBuildJoinIndex(js.tableName, js.refKeyCols)
        If idx Is Nothing Then GoTo CONT_R

        Dim outColName As String: outColName = Map_OutCols(r)
        If Not outHdrIx.Exists(outColName) Then GoTo CONT_R
        Dim outIx As Long: outIx = CLng(outHdrIx(outColName))

        Dim i As Long, comp As String, k As Long, ok As Boolean, refRow As Long
        For i = 2 To UBound(baseArr, 1)
            comp = "": ok = True
            For k = LBound(js.baseCols) To UBound(js.baseCols)
                If Not baseHdrIx.Exists(CStr(js.baseCols(k))) Then ok = False: Exit For
                If Len(comp) > 0 Then comp = comp & "|"
                comp = comp & CStr(baseArr(i, CLng(baseHdrIx(CStr(js.baseCols(k))))))
            Next
            If Not ok Then GoTo NEXT_I
            If idx.Exists(comp) Then
                refRow = CLng(idx(comp))
                Raw(i, outIx) = GetCellByHeader(TableData(js.tableName), refRow, refValCol)
            End If
NEXT_I:
        Next
CONT_R:
    Next
    Exit Sub
EH:
    ' ログ等あればここで
End Sub

'=== 参照テーブル名（この出力行で最初に指定されている非ベースのテーブル） ===
Private Function ResolveReferencedTableName_ByRow(ByVal outRowIdx As Long) As String
    Dim c As Long
    For c = LBound(Map_TblNames) To UBound(Map_TblNames)
        If Map_TblNames(c) <> "" Then
            ' ベースと同じ名前でも、JoinKey側の tableName と一致判定するのでここでは最初のテーブル名を返す
            ResolveReferencedTableName_ByRow = Map_TblNames(c)
            Exit Function
        End If
    Next
End Function

'=== 参照の「取得したい列名」（例: new_id） ===
Private Function ResolveReferencedValueColumn_ByRow(ByVal outRowIdx As Long) As String
    Dim c As Long, v As String
    For c = LBound(Map_TblNames) To UBound(Map_TblNames)
        v = Trim$(CStr(Map_SrcCols(outRowIdx, c)))
        If Len(v) > 0 Then
            ResolveReferencedValueColumn_ByRow = v
            Exit Function
        End If
    Next
End Function

'=== ヘッダ名で値を取得 ===
Private Function GetCellByHeader(ByRef arr As Variant, ByVal r As Long, ByVal colName As String) As String
    Dim j As Long
    For j = 1 To UBound(arr, 2)
        If CStr(arr(1, j)) = colName Then
            GetCellByHeader = CStr(arr(r, j))
            Exit Function
        End If
    Next
End Function

'==============================
' 既存の他ユーティリティ（抜粋プレースホルダ）
'==============================
Public Function GetListObjectByName(nameOrRange As String) As ListObject
    Dim ws As Worksheet, lo As ListObject
    For Each ws In ThisWorkbook.Worksheets
        For Each lo In ws.ListObjects
            If StrComp(lo.Name, nameOrRange, vbTextCompare) = 0 Then
                Set GetListObjectByName = lo: Exit Function
            End If
        Next
    Next
    Set GetListObjectByName = Nothing
End Function

Public Sub PasteToMasterByTable(masterLo As ListObject, dataArr As Variant)
    Dim rows As Long, cols As Long
    rows = UBound(dataArr, 1): cols = UBound(dataArr, 2)
    Dim newRange As Range
    Set newRange = masterLo.HeaderRowRange.Resize(rows + 1, cols)
    masterLo.Resize newRange
    masterLo.DataBodyRange.Value = dataArr
End Sub

'=== ここで参照する外部関数の宣言（プロジェクト既存実装に合わせてください） ===
Public Function LoadAllCsv(ByVal importPath As String, ByRef tblNames() As String, ByRef outDict As Object) As Boolean: End Function
Public Sub ApplyFiltersIfExist(): End Sub
Public Sub BuildKeyIndexes(): End Sub
Public Function PickBaseTableName(ByRef tblNames() As String, ByRef srcCols() As String, ByRef isKey() As Boolean) As String: End Function
Public Function BuildJoinedRaw(baseTbl As String) As Variant: End Function
Public Function ApplyTransformSmart(arr As Variant) As Variant: End Function
Public Sub EnsureFolder(ByVal path As String): End Sub

'=== ここまで: modProcess ===
