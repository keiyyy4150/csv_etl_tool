Option Explicit
'============================================================
' modPerf
' 概要: 大量データのインポート/加工の実行時パフォーマンスと進捗表示を補助するユーティリティ。
'      - WithPerfGuard / WithPerfGuardArgs: 計算/画面更新/イベント/警告を停止して安全実行（終了時に復元）
'      - 配列→ListObjectへのチャンク書き込み
'      - CSVの行チャンク読み込み＋即貼付
'      - 進捗表示API（BeginProgress/StepProgress/Pulse/EndProgress）
'============================================================

Private Type TAppState
    calc As XlCalculation
    scr As Boolean
    evt As Boolean
    dsp As Boolean
    stBar As Variant
End Type

Private mProgTotal As Long
Private mProgCurrent As Long
Private mProgLabel As String
Private mPulseIdx As Long

'================ WithPerfGuard (引数なし) ===================
' 概要: 画面更新/計算/イベント/警告を一時停止し、処理後に復元するガード。処理時間短縮と安定化を担います。
' 引数:
'   ByVal procName As String  … 呼び出し先 'Module.Procedure' 名
' 備考: 例外発生時も確実に復元。
Public Sub WithPerfGuard(ByVal runBody As String, Optional ByVal showProgress As Boolean = True)
    Dim st As TAppState
    On Error GoTo EH

    st.calc = Application.Calculation
    st.scr = Application.ScreenUpdating
    st.evt = Application.EnableEvents
    st.dsp = Application.DisplayAlerts
    st.stBar = Application.StatusBar

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    If showProgress Then Application.StatusBar = "処理を開始しています..."

    Application.Run runBody

Done:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Exit Sub
EH:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'================ WithPerfGuardArgs (引数あり) ================
' 概要: Application.Run に引数を渡したい場合はこちらを使用
' 概要: WithPerfGuard の引数付き版。ProcName と引数1つを受け取り Application.Run で呼び出します。
' 引数:
'   ByVal procName As String  … 呼び出し先 'Module.Procedure' 名
'   ByVal showProgress As Boolean  … 進捗表示を有効化するか
'   ByVal arg1 As Variant  … 呼び先に渡す引数
Public Sub WithPerfGuardArgs(ByVal runBody As String, ByVal showProgress As Boolean, ParamArray args() As Variant)
    Dim st As TAppState
    On Error GoTo EH

    st.calc = Application.Calculation
    st.scr = Application.ScreenUpdating
    st.evt = Application.EnableEvents
    st.dsp = Application.DisplayAlerts
    st.stBar = Application.StatusBar

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    If showProgress Then Application.StatusBar = "処理を開始しています..."

    ' Application.Run は ParamArray をそのまま渡せないため引数数で分岐
    Select Case UBound(args)
        Case -1: Application.Run runBody
        Case 0:  Application.Run runBody, args(0)
        Case 1:  Application.Run runBody, args(0), args(1)
        Case 2:  Application.Run runBody, args(0), args(1), args(2)
        Case 3:  Application.Run runBody, args(0), args(1), args(2), args(3)
        Case Else
            ' 必要なら上限を拡張
            Dim i As Long
            Dim a1, a2, a3, a4, a5 As Variant
            a1 = args(0): a2 = args(1): a3 = args(2): a4 = args(3): a5 = args(4)
            Application.Run runBody, a1, a2, a3, a4, a5
    End Select

Done:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Exit Sub
EH:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'================ Progress API ===============================
' 概要: 進捗バーを初期化し、ステータス文字列を表示します。
' 引数:
'   msg As String  … 開始メッセージ
Public Sub BeginProgress(ByVal total As Long, ByVal label As String)
    mProgTotal = IIf(total < 1, 1, total)
    mProgCurrent = 0
    mProgLabel = label
    mPulseIdx = 0
    Application.StatusBar = label & " 0% (0/" & mProgTotal & ")"
End Sub

Public Sub StepProgress(ByVal current As Long)
    Dim pct As Long
    mProgCurrent = current
    If mProgCurrent < 0 Then mProgCurrent = 0
    If mProgCurrent > mProgTotal Then mProgCurrent = mProgTotal
    pct = CLng((mProgCurrent / mProgTotal) * 100)
    Application.StatusBar = mProgLabel & " " & pct & "% (" & mProgCurrent & "/" & mProgTotal & ")"
End Sub
' 概要: 進捗バーを更新し、任意のメッセージを表示します。UI応答性を確保するため DoEvents も呼びます。
' 引数:
'   msg As String  … 表示メッセージ

Public Sub Pulse(ByVal label As String)
    Dim spinner As String
    mPulseIdx = (mPulseIdx + 1) Mod 4
    Select Case mPulseIdx
        Case 0: spinner = "|"
        Case 1: spinner = "/"
        Case 2: spinner = "-"
        Case 3: spinner = "\"
    End Select
    Application.StatusBar = label & " " & spinner
    DoEvents
End Sub
' 概要: 進捗バーを完了状態にしてメッセージを表示します。
' 引数:
'   msg As String  … 完了メッセージ

Public Sub EndProgress(Optional ByVal label As String = "完了")
    Application.StatusBar = label
End Sub

'================ ListObject 書き込み ========================
Public Sub WriteArrayToListObjectChunked(ByVal lo As ListObject, ByRef data2D As Variant, _
    ByVal startRow As Long, ByVal chunkRows As Long, Optional ByVal pulseLabel As String = "書き込み中")
    Dim totalRows As Long, totalCols As Long
    Dim r0 As Long, r1 As Long, wRow As Long, chunk As Long
    Dim tgt As Range, arr As Variant

    If IsEmpty(data2D) Then Exit Sub
    On Error GoTo EH

    totalRows = UBound(data2D, 1) - LBound(data2D, 1) + 1
    totalCols = UBound(data2D, 2) - LBound(data2D, 2) + 1
    wRow = startRow
    chunk = IIf(chunkRows <= 0, 1000, chunkRows)

    Dim needRows As Long: needRows = startRow - 1 + totalRows
    EnsureTableDataRows lo, needRows

    BeginProgress totalRows, pulseLabel
    For r0 = 1 To totalRows Step chunk
        r1 = Application.WorksheetFunction.Min(totalRows, r0 + chunk - 1)
        arr = SliceRows(data2D, r0, r1)
        Set tgt = lo.DataBodyRange.rows(wRow).Resize(r1 - r0 + 1, totalCols)
        tgt.Value = arr
        wRow = wRow + (r1 - r0 + 1)
        StepProgress r1
        If (r1 Mod (chunk * 2)) = 0 Then DoEvents
    Next
    EndProgress "書き込み完了"
    Exit Sub
EH:
    EndProgress "書き込み中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Function SliceRows(ByRef data As Variant, ByVal r0 As Long, ByVal r1 As Long) As Variant
    Dim rows As Long, cols As Long, i As Long, j As Long, o As Variant
    rows = r1 - r0 + 1
    cols = UBound(data, 2)
    ReDim o(1 To rows, 1 To cols)
    For i = 1 To rows
        For j = 1 To cols
            o(i, j) = data(r0 + i - 1, j)
        Next
    Next
    SliceRows = o
End Function

'================ CSV チャンク読み込み =======================
Public Sub ImportCsvChunked(ByVal filePath As String, ByVal lo As ListObject, _
    Optional ByVal headerRows As Long = 1, Optional ByVal chunkRows As Long = 1000, _
    Optional ByVal delim As String = "")
    On Error GoTo EH
    Dim F As Integer: F = FreeFile
    Dim line As String
    Dim data As Variant, arr As Variant
    Dim i As Long, j As Long
    Dim startRow As Long: startRow = 1
    Dim detected As String
    Dim cnt As Long

    If delim = "" Then
        detected = DetectDelimiterFromTopLines(filePath)
        If detected <> "" Then delim = detected Else delim = ","
    End If

    FastClearTable lo
    Open filePath For Input As #F

    If headerRows >= 1 Then
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        EnsureTableHeader lo, arr
    End If

    Dim block As Long: block = IIf(chunkRows <= 0, 1000, chunkRows)
    Dim collected As Long: collected = 0
    ReDim data(1 To block, 1 To lo.ListColumns.Count)

    BeginProgress 1, "読込準備中"
    Do While Not EOF(F)
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        collected = collected + 1: cnt = cnt + 1
        For j = 1 To lo.ListColumns.Count
            If j <= UBound(arr) + 1 Then
                data(collected, j) = arr(j - 1)
            Else
                data(collected, j) = Empty
            End If
        Next
        If collected = block Then
            StepProgress cnt
            WriteArrayToListObjectChunked lo, data, startRow, block, "CSV書き込み"
            startRow = startRow + block
            collected = 0
            ReDim data(1 To block, 1 To lo.ListColumns.Count)
            Pulse "CSV読込中"
        End If
    Loop

    If collected > 0 Then
        Dim tail As Variant
        ReDim tail(1 To collected, 1 To lo.ListColumns.Count)
        For i = 1 To collected
            For j = 1 To lo.ListColumns.Count
                tail(i, j) = data(i, j)
            Next
        Next
        WriteArrayToListObjectChunked lo, tail, startRow, block, "CSV書き込み"
    End If

    Close #F
    EndProgress "CSV読込完了"
    Exit Sub
EH:
    On Error Resume Next
    Close #F
    EndProgress "CSV読込中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Function DetectDelimiterFromTopLines(ByVal filePath As String) As String
    On Error GoTo EH
    Dim F As Integer: F = FreeFile
    Dim l As String
    Open filePath For Input As #F
    If Not EOF(F) Then
        Line Input #F, l
        If InStr(l, vbTab) > 0 Then DetectDelimiterFromTopLines = vbTab: GoTo Done
        If InStr(l, ";") > 0 Then DetectDelimiterFromTopLines = ";": GoTo Done
        If InStr(l, ",") > 0 Then DetectDelimiterFromTopLines = ",": GoTo Done
    End If
Done:
    Close #F
    Exit Function
EH:
    On Error Resume Next
    Close #F
End Function

Private Function SplitCsvLine(ByVal line As String, ByVal delim As String) As Variant
    Dim res() As String, i As Long, ch As String, inQ As Boolean
    ReDim res(0 To 0): res(0) = ""
    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)
        If ch = """" Then
            If inQ And i < Len(line) And Mid$(line, i + 1, 1) = """" Then
                res(UBound(res)) = res(UBound(res)) & """"
                i = i + 1
            Else
                inQ = Not inQ
            End If
        ElseIf ch = delim And Not inQ Then
            ReDim Preserve res(0 To UBound(res) + 1)
            res(UBound(res)) = ""
        Else
            res(UBound(res)) = res(UBound(res)) & ch
        End If
    Next
    SplitCsvLine = res
End Function

'================ ListObject 補助 ============================
' 概要: 指定 ListObject のデータ行が配列貼付に十分な行数か確認し、不足時に拡張します。
' 引数:
'   lo As ListObject  … 対象テーブル
'   rows As Long  … 必要行数（ヘッダ除く）
Public Sub EnsureTableDataRows(ByVal lo As ListObject, ByVal needRows As Long)
    Dim cur As Long
    On Error GoTo EH
    cur = 0
    If Not lo.DataBodyRange Is Nothing Then cur = lo.DataBodyRange.rows.Count
    If needRows > cur Then
        Dim addN As Long: addN = needRows - cur
        lo.ListRows.Add AlwaysInsert:=True, Count:=addN
    ElseIf needRows < cur Then
        Dim delN As Long: delN = cur - needRows
        Dim i As Long
        For i = 1 To delN
            lo.ListRows(lo.ListRows.Count).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub
' 概要: ListObject のヘッダを指定配列の1行目と一致させます（不足列の追加・余剰列の削除）。
' 引数:
'   lo As ListObject  … 対象テーブル
'   arr As Variant  … ヘッダ付配列

Public Sub EnsureTableHeader(ByVal lo As ListObject, ByRef headers As Variant)
    Dim i As Long, needCols As Long, curCols As Long
    needCols = UBound(headers) + 1
    curCols = lo.ListColumns.Count
    If needCols > curCols Then
        For i = 1 To needCols - curCols
            lo.ListColumns.Add
        Next
    ElseIf needCols < curCols Then
        For i = curCols To needCols + 1 Step -1
            lo.ListColumns(i).Delete
        Next
    End If
    For i = 1 To needCols
        lo.ListColumns(i).name = headers(i - 1)
    End If
End Sub
' 概要: ListObject のデータ行を高速消去。表示更新を抑制しつつ効率よく初期化します。
' 引数:
'   lo As ListObject  … クリア対象テーブル

Public Sub FastClearTable(ByVal lo As ListObject)
    On Error GoTo EH
    If Not lo.DataBodyRange Is Nothing Then
        lo.DataBodyRange.ClearContents
        Dim r As Long
        For r = lo.ListRows.Count To 1 Step -1
            lo.ListRows(r).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub
