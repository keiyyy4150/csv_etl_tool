# ================================
# CSVエンコード/改行修正 → *_fixed.csv 生成
# 元CSVはZIP化した後に削除
# ================================

$folderPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
$csvFiles   = Get-ChildItem -LiteralPath $folderPath -Filter *.csv -File

if (-not $csvFiles) {
    Write-Host "CSVファイルが見つかりません。フォルダ: $folderPath"
    return
}

# ZIPファイル（重複しないようタイムスタンプ付与）
$zipPath = Join-Path $folderPath ("original_csv_backup_" + (Get-Date -Format "yyyyMMdd_HHmmss") + ".zip")

# 既存同名ZIPがあれば削除（通常は衝突しない想定）
if (Test-Path -LiteralPath $zipPath) {
    Remove-Item -LiteralPath $zipPath -Force
}

# 例外フォールバック付きエンコーディング（厳密判定用）
$Utf8Strict = [System.Text.UTF8Encoding]::new($false, $true)  # BOMなし、エラー時例外
$SjisStrict = [System.Text.Encoding]::GetEncoding(
    932,
    [System.Text.EncoderExceptionFallback]::new(),
    [System.Text.DecoderExceptionFallback]::new()
)
$Utf16LE    = [System.Text.Encoding]::Unicode
$Utf16BE    = [System.Text.Encoding]::BigEndianUnicode
$Utf8BOMOut = [System.Text.UTF8Encoding]::new($true)          # 出力はUTF-8(BOM付)

function Get-TextStrict {
    param([byte[]]$Bytes)

    # BOM検出
    if ($Bytes.Length -ge 3 -and $Bytes[0] -eq 0xEF -and $Bytes[1] -eq 0xBB -and $Bytes[2] -eq 0xBF) {
        return [System.Text.Encoding]::UTF8.GetString($Bytes, 3, $Bytes.Length - 3)
    }
    elseif ($Bytes.Length -ge 2 -and $Bytes[0] -eq 0xFF -and $Bytes[1] -eq 0xFE) {
        return $Utf16LE.GetString($Bytes)
    }
    elseif ($Bytes.Length -ge 2 -and $Bytes[0] -eq 0xFE -and $Bytes[1] -eq 0xFF) {
        return $Utf16BE.GetString($Bytes)
    }

    # UTF-8(厳密)→Shift_JIS(厳密)の順に試す
    try   { return $Utf8Strict.GetString($Bytes) } catch {}
    try   { return $SjisStrict.GetString($Bytes) } catch {}

    # 最後の手段（緩めのUTF-8）
    return [System.Text.Encoding]::UTF8.GetString($Bytes)
}

# 引用符内の改行をスペースに置換（CSVのルールに沿った簡易状態機械）
function Fix-EmbeddedNewlinesInQuotedFields {
    param([string]$Text)

    $sb = [System.Text.StringBuilder]::new()
    $inQuote = $false
    $len = $Text.Length
    $i = 0

    while ($i -lt $len) {
        $ch = $Text[$i]

        if ($ch -eq '"') {
            # 連続する "" はエスケープされた引用符 → 1つの " として出力、状態は維持
            if (($i + 1) -lt $len -and $Text[$i + 1] -eq '"') {
                [void]$sb.Append('"')
                $i += 2
                continue
            } else {
                # 引用符の開閉をトグル
                $inQuote = -not $inQuote
                [void]$sb.Append($ch)
                $i++
                continue
            }
        }

        if ($inQuote -and ($ch -eq "`r" -or $ch -eq "`n")) {
            # フィールド内の改行はスペースへ
            # もしCRLFのCR側だったら次のLFはスキップ
            [void]$sb.Append(' ')
            if ($ch -eq "`r" -and ($i + 1) -lt $len -and $Text[$i + 1] -eq "`n") {
                $i += 2
            } else {
                $i += 1
            }
            continue
        }

        # 通常文字
        [void]$sb.Append($ch)
        $i++
    }

    return $sb.ToString()
}

# 改行統一（混在→LF正規化→CRLF）
function Normalize-Newlines {
    param([string]$Text)
    $t = $Text -replace "`r`n|`r|`n", "`n"
    return ($t -replace "`n", "`r`n")
}

# 1) 先にZIP化
Write-Host "=== 元CSVをZIPに圧縮中... ==="
Compress-Archive -LiteralPath ($csvFiles.FullName) -DestinationPath $zipPath -Force
Write-Host "→ ZIP作成完了: $zipPath"
Write-Host ""

# 2) 修正版を作成（*_fixed.csv）
Write-Host "=== CSV修正版（*_fixed.csv）を作成中... ==="
foreach ($file in $csvFiles) {
    Write-Host ("修正中: " + $file.Name)

    $bytes = [System.IO.File]::ReadAllBytes($file.FullName)
    $text  = Get-TextStrict -Bytes $bytes

    # まず引用符内の改行を除去（スペース化）
    $text  = Fix-EmbeddedNewlinesInQuotedFields -Text $text

    # 全体の改行をCRLFへ統一
    $text  = Normalize-Newlines -Text $text

    $newFile = Join-Path $folderPath ($file.BaseName + "_fixed.csv")
    [System.IO.File]::WriteAllText($newFile, $text, $Utf8BOMOut)

    Write-Host ("→ 修正版を作成: " + $newFile)
}

# 3) 元のCSVを削除（ZIP化済みなのでフォルダからは消す）
Write-Host ""
Write-Host "=== 元のCSVをフォルダから削除します（ZIPには保存済み） ==="
foreach ($file in $csvFiles) {
    Remove-Item -LiteralPath $file.FullName -Force
    Write-Host ("削除: " + $file.Name)
}

Write-Host ""
Write-Host "=== 完了！==="
Write-Host "・元データ: $zipPath に保存"
Write-Host "・修正版: *_fixed.csv が同フォルダに残っています（UTF-8 BOM / CRLF）"







CsvDoctor.ps1
param(
  [Parameter(Mandatory=$true)]
  [string]$Path
)

if (!(Test-Path -LiteralPath $Path)) { Write-Host "ファイルがありません: $Path"; exit 1 }

$bytes = [IO.File]::ReadAllBytes($Path)
$size  = $bytes.Length

function Hex($arr,$n=16){
  ($arr[0..([Math]::Min($n,$arr.Length)-1)] | ForEach-Object { $_.ToString("X2") }) -join " "
}

# 署名・BOM判定
$magic = Hex $bytes 8
$bom   = if ($bytes.Length -ge 3 -and $bytes[0..2] -ceq (0xEF,0xBB,0xBF)) {"UTF-8-BOM"}
        elseif ($bytes.Length -ge 2 -and $bytes[0..1] -ceq (0xFF,0xFE)) {"UTF-16LE-BOM"}
        elseif ($bytes.Length -ge 2 -and $bytes[0..1] -ceq (0xFE,0xFF)) {"UTF-16BE-BOM"}
        else {"(none)"}

# 圧縮/形式の可能性
$kind = switch -regex ($magic) {
  '^50 4B 03 04' { "ZIP系（XLSX/ODS/ZIPの可能性）" ; break }
  '^1F 8B'       { "GZIP（.gz）" ; break }
  default        { 
    # テキスト先頭でHTMLをざっくり判定
    $head = [Text.Encoding]::ASCII.GetString($bytes[0..([Math]::Min(512,$bytes.Length)-1)])
    if ($head -match '^\s*<(html|!DOCTYPE|meta|head)') { "HTML/WEBページの可能性" } else { "不明" }
  }
}

# NUL/制御文字の混入
$nulCount  = ($bytes | Where-Object { $_ -eq 0 }).Count
$ctrlCount = ($bytes | Where-Object { ($_ -lt 0x09) -or (($_ -gt 0x0D) -and ($_ -lt 0x20)) }).Count

# 改行の推定
$textSample = [Text.Encoding]::ASCII.GetString($bytes[0..([Math]::Min(200000,$bytes.Length)-1)])
$crlf = ([regex]::Matches($textSample,"`r`n")).Count
$lf   = ([regex]::Matches($textSample,"(?<!`r)`n")).Count
$cr   = ([regex]::Matches($textSample,"`r(?!`n)")).Count

# UTF-8妥当性チェック（例外フォールバック）
$utf8Strict = [Text.UTF8Encoding]::new($false,$true)
$utf8ok = $true
try { $null = $utf8Strict.GetString($bytes) } catch { $utf8ok = $false }

# SJISでも読めるか（例外フォールバック）
$encSJIS = [Text.Encoding]::GetEncoding(932,
  [Text.EncoderExceptionFallback]::new(),
  [Text.DecoderExceptionFallback]::new())
$sjisok = $true
try { $null = $encSJIS.GetString($bytes) } catch { $sjisok = $false }

# 区切り文字の当て推量（先頭2万文字から）
$probe = ""
try { $probe = [Text.Encoding]::UTF8.GetString($bytes[0..([Math]::Min(20000,$bytes.Length)-1)]) } catch {}
$comma    = ([regex]::Matches($probe,',')).Count
$tab      = ([regex]::Matches($probe,"`t")).Count
$semicolon= ([regex]::Matches($probe,';')).Count
$delim = @{"comma"=$comma;"tab"=$tab;"semicolon"=$semicolon} `
        | Sort-Object Value -Descending | Select-Object -First 1 | ForEach-Object {$_.Name}

Write-Host "=== CSV Doctor Report ==="
Write-Host "Path     : $Path"
Write-Host "Size     : $size bytes"
Write-Host "Magic    : $magic"
Write-Host "BOM      : $bom"
Write-Host "KindHint : $kind"
Write-Host "NUL bytes: $nulCount"
Write-Host "Ctrl char: $ctrlCount  （タブ/改行以外の制御文字の概数）"
Write-Host "LineEnds : CRLF=$crlf, LF=$lf, CR=$cr"
Write-Host "UTF-8 ok : $utf8ok"
Write-Host "SJIS ok  : $sjisok"
Write-Host "Delimiter guess: $delim"