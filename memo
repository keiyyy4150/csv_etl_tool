Option Explicit
'============================================================
' modPerf
' 概要: 大量データのインポート/加工の実行時パフォーマンスを安定させるための共通ユーティリティ。
'      - 計算/画面更新/イベント停止（実行後に必ず元へ戻す）
'      - 2次元配列をListObjectへチャンク書き込み（列数が多い場合でも固まりにくい）
'      - CSVを行チャンクで読み込み（巨大ファイルでも段階的に処理）
'      - 進捗表示（StatusBar）と定期的なDoEvents（UIフリーズ抑止）
'============================================================

'--- 実行時オプションの退避用 ---
Private Type TAppState
    calc As XlCalculation
    scr As Boolean
    evt As Boolean
    dsp As Boolean
    stBar As Variant
End Type

'--- 実行時オプションを安全に切り替えるガード ---
' 概要: 処理前に計算/画面更新/イベント/表示系を停止し、終了時に必ず復元する。
' 引数:
'   runBody      … 実際の処理を行うデリゲート (Sub 実処理())
'   showProgress … True でステータスバー使用
Public Sub WithPerfGuard(ByVal runBody As String, Optional ByVal showProgress As Boolean = True)
    Dim st As TAppState
    On Error GoTo EH

    ' 状態保存 & 低負荷設定
    st.calc = Application.Calculation
    st.scr = Application.ScreenUpdating
    st.evt = Application.EnableEvents
    st.dsp = Application.DisplayAlerts
    st.stBar = Application.StatusBar

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    If showProgress Then Application.StatusBar = "処理を開始しています..."

    Application.Run runBody
Done:
    ' 復元
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Exit Sub
EH:
    ' 例外でも復元
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'--- 2次元配列をListObjectへチャンク書き込み ---
' 概要: 大きな配列を指定サイズの行塊ごとにDataBodyRangeへ書き込みます。
' 引数:
'   lo        … 書き込み先ListObject（ヘッダ行あり想定）
'   data2D    … (1-based推奨) 2次元Variant配列（ヘッダ含まないデータ部）
'   startRow  … lo.DataBodyRangeの先頭からの書き込み開始行(1-based)
'   chunkRows … チャンク行数（例: 500～5000）
'   doEventsEvery … 何チャンクごとにDoEventsするか（0=しない）
Public Sub WriteArrayToListObjectChunked(ByVal lo As ListObject, ByRef data2D As Variant, _
    ByVal startRow As Long, ByVal chunkRows As Long, Optional ByVal doEventsEvery As Long = 2)

    Dim totalRows As Long, totalCols As Long
    Dim r0 As Long, r1 As Long, wRow As Long, chunk As Long, chunkCount As Long
    Dim tgt As Range, arr As Variant

    If IsEmpty(data2D) Then Exit Sub
    On Error GoTo EH

    totalRows = UBound(data2D, 1) - LBound(data2D, 1) + 1
    totalCols = UBound(data2D, 2) - LBound(data2D, 2) + 1
    wRow = startRow
    chunk = IIf(chunkRows <= 0, 1000, chunkRows)

    ' 必要行数にテーブルを拡張
    Dim needRows As Long: needRows = startRow - 1 + totalRows
    EnsureTableDataRows lo, needRows

    For r0 = 1 To totalRows Step chunk
        r1 = Application.WorksheetFunction.Min(totalRows, r0 + chunk - 1)
        arr = SliceRows(data2D, r0, r1)

        Set tgt = lo.DataBodyRange.Rows(wRow).Resize(r1 - r0 + 1, totalCols)
        tgt.Value = arr

        wRow = wRow + (r1 - r0 + 1)
        chunkCount = chunkCount + 1
        If doEventsEvery > 0 Then
            If (chunkCount Mod doEventsEvery) = 0 Then DoEvents
        End If
        Application.StatusBar = "書き込み中… " & wRow - startRow + 1 & " / " & totalRows & " 行"
    Next
    Application.StatusBar = False
    Exit Sub
EH:
    Application.StatusBar = False
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'--- ListObjectの行数を目的のデータ行数に合わせる ---
' 概要: DataBodyRange の行数が不足していれば拡張し、多ければ削除します。
' 引数:
'   lo       … 対象ListObject
'   needRows … データ行数（ヘッダ除く）
Public Sub EnsureTableDataRows(ByVal lo As ListObject, ByVal needRows As Long)
    Dim cur As Long
    On Error GoTo EH

    cur = 0
    If Not lo.DataBodyRange Is Nothing Then cur = lo.DataBodyRange.Rows.Count

    If needRows > cur Then
        Dim addN As Long: addN = needRows - cur
        lo.ListRows.Add AlwaysInsert:=True, Count:=addN
    ElseIf needRows < cur Then
        Dim delN As Long: delN = cur - needRows
        Dim i As Long
        For i = 1 To delN
            lo.ListRows(lo.ListRows.Count).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'--- 2D配列の部分行抽出 ---
' 概要: data(r0..r1, 1..n) を切り出す。
Private Function SliceRows(ByRef data As Variant, ByVal r0 As Long, ByVal r1 As Long) As Variant
    Dim rows As Long, cols As Long, i As Long, j As Long, o As Variant
    rows = r1 - r0 + 1
    cols = UBound(data, 2)
    ReDim o(1 To rows, 1 To cols)
    For i = 1 To rows
        For j = 1 To cols
            o(i, j) = data(r0 + i - 1, j)
        Next
    Next
    SliceRows = o
End Function

'--- CSVを行チャンクで読み込んで即書き込み（低メモリ） ---
' 概要: 巨大CSVを1,000行などの塊で読み出し、パースしてListObjectへ順次貼り付ける。
' 引数:
'   filePath     … CSVファイルのフルパス
'   lo           … 書き込み先ListObject（ヘッダは別途セット想定）
'   headerRows   … ヘッダ行数（通常1）
'   chunkRows    … 読込チャンク行数（例: 1000）
'   delim        … 区切り文字（"", "," , vbTab など。空なら自動推定）
Public Sub ImportCsvChunked(ByVal filePath As String, ByVal lo As ListObject, _
    Optional ByVal headerRows As Long = 1, Optional ByVal chunkRows As Long = 1000, _
    Optional ByVal delim As String = "")
    On Error GoTo EH

    Dim F As Integer: F = FreeFile
    Dim line As String
    Dim data As Variant, arr As Variant
    Dim i As Long, j As Long
    Dim startRow As Long: startRow = 1
    Dim detected As String

    ' 区切り自動推定（先頭行）
    If delim = "" Then
        detected = DetectDelimiterFromTopLines(filePath)
        If detected <> "" Then delim = detected Else delim = ","
    End If

    ' 既存データクリア（高速）
    FastClearTable lo

    Open filePath For Input As #F

    ' ヘッダ処理
    If headerRows >= 1 Then
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        EnsureTableHeader lo, arr
    End If

    ' チャンク読みループ
    Dim block As Long: block = IIf(chunkRows <= 0, 1000, chunkRows)
    Dim collected As Long: collected = 0
    ReDim data(1 To block, 1 To lo.ListColumns.Count)

    Do While Not EOF(F)
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        collected = collected + 1
        For j = 1 To lo.ListColumns.Count
            If j <= UBound(arr) + 1 Then
                data(collected, j) = arr(j - 1)
            Else
                data(collected, j) = Empty
            End If
        Next

        If collected = block Then
            WriteArrayToListObjectChunked lo, data, startRow, block, 2
            startRow = startRow + block
            collected = 0
            ReDim data(1 To block, 1 To lo.ListColumns.Count)
        End If
    Loop

    ' 端数
    If collected > 0 Then
        Dim tail As Variant
        ReDim tail(1 To collected, 1 To lo.ListColumns.Count)
        For i = 1 To collected
            For j = 1 To lo.ListColumns.Count
                tail(i, j) = data(i, j)
            Next
        Next
        WriteArrayToListObjectChunked lo, tail, startRow, block, 0
    End If

    Close #F
    Application.StatusBar = False
    Exit Sub
EH:
    On Error Resume Next
    Close #F
    Application.StatusBar = False
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'--- 先頭数行から区切り推定（簡易） ---
Private Function DetectDelimiterFromTopLines(ByVal filePath As String) As String
    On Error GoTo EH
    Dim F As Integer: F = FreeFile
    Dim l As String
    Open filePath For Input As #F
    If Not EOF(F) Then
        Line Input #F, l
        If InStr(l, vbTab) > 0 Then DetectDelimiterFromTopLines = vbTab: GoTo Done
        If InStr(l, ";") > 0 Then DetectDelimiterFromTopLines = ";": GoTo Done
        If InStr(l, ",") > 0 Then DetectDelimiterFromTopLines = ",": GoTo Done
    End If
Done:
    Close #F
    Exit Function
EH:
    On Error Resume Next
    Close #F
End Function

'--- 1行のCSVを区切る（ダブルクォート対応・簡易RFC準拠） ---
Private Function SplitCsvLine(ByVal line As String, ByVal delim As String) As Variant
    Dim res() As String, i As Long, ch As String, inQ As Boolean
    ReDim res(0 To 0): res(0) = ""
    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)
        If ch = """" Then
            If inQ And i < Len(line) And Mid$(line, i + 1, 1) = """" Then
                res(UBound(res)) = res(UBound(res)) & """"
                i = i + 1
            Else
                inQ = Not inQ
            End If
        ElseIf ch = delim And Not inQ Then
            ReDim Preserve res(0 To UBound(res) + 1)
            res(UBound(res)) = ""
        Else
            res(UBound(res)) = res(UBound(res)) & ch
        End If
    Next
    SplitCsvLine = res
End Function

'--- ListObjectのヘッダを配列の文字列で上書き・列数調整 ---
Private Sub EnsureTableHeader(ByVal lo As ListObject, ByRef headers As Variant)
    Dim i As Long, needCols As Long, curCols As Long
    needCols = UBound(headers) + 1
    curCols = lo.ListColumns.Count

    If needCols > curCols Then
        For i = 1 To needCols - curCols
            lo.ListColumns.Add
        Next
    ElseIf needCols < curCols Then
        For i = curCols To needCols + 1 Step -1
            lo.ListColumns(i).Delete
        Next
    End If

    For i = 1 To needCols
        lo.ListColumns(i).Name = headers(i - 1)
    End If
End Sub

'--- ListObjectデータの高速クリア ---
Public Sub FastClearTable(ByVal lo As ListObject)
    On Error GoTo EH
    If Not lo.DataBodyRange Is Nothing Then
        lo.DataBodyRange.ClearContents
        Dim r As Long
        For r = lo.ListRows.Count To 1 Step -1
            lo.ListRows(r).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'--- 使用例: Masterへ巨大CSVを分割インポート ---
'   Sub Example_ImportLargeCsv()
'       WithPerfGuard "modPerf.Run_ExampleImport"
'   End Sub
Public Sub Run_ExampleImport()
    Dim lo As ListObject
    Set lo = ThisWorkbook.Worksheets("Master").ListObjects("Master")
    ImportCsvChunked "C:\path\to\big.csv", lo, 1, 2000, ","
End Sub
