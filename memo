Option Explicit
'============================================================
' modPerf
' 概要: 大量データのインポート/加工の実行時パフォーマンスと進捗表示を補助するユーティリティ。
'      - WithPerfGuard: 計算/画面更新/イベント/警告を停止して安全実行（終了時に復元）
'      - 配列→ListObjectへのチャンク書き込み
'      - CSVの行チャンク読み込み＋即貼付
'      - 進捗表示API（BeginProgress/StepProgress/Pulse/EndProgress）
'============================================================

'--- 実行時オプションの退避用 ---
Private Type TAppState
    calc As XlCalculation
    scr As Boolean
    evt As Boolean
    dsp As Boolean
    stBar As Variant
End Type

'--- 進捗用の内部状態 ---
Private mProgTotal As Long
Private mProgCurrent As Long
Private mProgLabel As String
Private mPulseIdx As Long

'================ WithPerfGuard ==============================
Public Sub WithPerfGuard(ByVal runBody As String, Optional ByVal showProgress As Boolean = True)
    Dim st As TAppState
    On Error GoTo EH

    st.calc = Application.Calculation
    st.scr = Application.ScreenUpdating
    st.evt = Application.EnableEvents
    st.dsp = Application.DisplayAlerts
    st.stBar = Application.StatusBar

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    If showProgress Then Application.StatusBar = "処理を開始しています..."

    Application.Run runBody

Done:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Exit Sub
EH:
    Application.Calculation = st.calc
    Application.ScreenUpdating = st.scr
    Application.EnableEvents = st.evt
    Application.DisplayAlerts = st.dsp
    Application.StatusBar = st.stBar
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

'================ Progress API ===============================
Public Sub BeginProgress(ByVal total As Long, ByVal label As String)
    mProgTotal = IIf(total < 1, 1, total)
    mProgCurrent = 0
    mProgLabel = label
    mPulseIdx = 0
    Application.StatusBar = label & " 0% (0/" & mProgTotal & ")"
End Sub

Public Sub StepProgress(ByVal current As Long)
    Dim pct As Long
    mProgCurrent = current
    If mProgCurrent < 0 Then mProgCurrent = 0
    If mProgCurrent > mProgTotal Then mProgCurrent = mProgTotal
    pct = CLng((mProgCurrent / mProgTotal) * 100)
    Application.StatusBar = mProgLabel & " " & pct & "% (" & mProgCurrent & "/" & mProgTotal & ")"
End Sub

Public Sub Pulse(ByVal label As String)
    Dim spinner As String
    mPulseIdx = (mPulseIdx + 1) Mod 4
    Select Case mPulseIdx
        Case 0: spinner = "|"
        Case 1: spinner = "/"
        Case 2: spinner = "-"
        Case 3: spinner = "\"
    End Select
    Application.StatusBar = label & " " & spinner
    DoEvents
End Sub

Public Sub EndProgress(Optional ByVal label As String = "完了")
    Application.StatusBar = label
End Sub

'================ ListObject 書き込み ========================
Public Sub WriteArrayToListObjectChunked(ByVal lo As ListObject, ByRef data2D As Variant, _
    ByVal startRow As Long, ByVal chunkRows As Long, Optional ByVal pulseLabel As String = "書き込み中")
    Dim totalRows As Long, totalCols As Long
    Dim r0 As Long, r1 As Long, wRow As Long, chunk As Long
    Dim tgt As Range, arr As Variant

    If IsEmpty(data2D) Then Exit Sub
    On Error GoTo EH

    totalRows = UBound(data2D, 1) - LBound(data2D, 1) + 1
    totalCols = UBound(data2D, 2) - LBound(data2D, 2) + 1
    wRow = startRow
    chunk = IIf(chunkRows <= 0, 1000, chunkRows)

    Dim needRows As Long: needRows = startRow - 1 + totalRows
    EnsureTableDataRows lo, needRows

    BeginProgress totalRows, pulseLabel
    For r0 = 1 To totalRows Step chunk
        r1 = Application.WorksheetFunction.Min(totalRows, r0 + chunk - 1)
        arr = SliceRows(data2D, r0, r1)
        Set tgt = lo.DataBodyRange.Rows(wRow).Resize(r1 - r0 + 1, totalCols)
        tgt.Value = arr
        wRow = wRow + (r1 - r0 + 1)
        StepProgress r1
        If (r1 Mod (chunk * 2)) = 0 Then DoEvents
    Next
    EndProgress "書き込み完了"
    Exit Sub
EH:
    EndProgress "書き込み中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Function SliceRows(ByRef data As Variant, ByVal r0 As Long, ByVal r1 As Long) As Variant
    Dim rows As Long, cols As Long, i As Long, j As Long, o As Variant
    rows = r1 - r0 + 1
    cols = UBound(data, 2)
    ReDim o(1 To rows, 1 To cols)
    For i = 1 To rows
        For j = 1 To cols
            o(i, j) = data(r0 + i - 1, j)
        Next
    Next
    SliceRows = o
End Function

'================ CSV チャンク読み込み =======================
Public Sub ImportCsvChunked(ByVal filePath As String, ByVal lo As ListObject, _
    Optional ByVal headerRows As Long = 1, Optional ByVal chunkRows As Long = 1000, _
    Optional ByVal delim As String = "")
    On Error GoTo EH
    Dim F As Integer: F = FreeFile
    Dim line As String
    Dim data As Variant, arr As Variant
    Dim i As Long, j As Long
    Dim startRow As Long: startRow = 1
    Dim detected As String
    Dim cnt As Long

    If delim = "" Then
        detected = DetectDelimiterFromTopLines(filePath)
        If detected <> "" Then delim = detected Else delim = ","
    End If

    FastClearTable lo
    Open filePath For Input As #F

    If headerRows >= 1 Then
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        EnsureTableHeader lo, arr
    End If

    Dim block As Long: block = IIf(chunkRows <= 0, 1000, chunkRows)
    Dim collected As Long: collected = 0
    ReDim data(1 To block, 1 To lo.ListColumns.Count)

    BeginProgress 1, "読込準備中"
    Do While Not EOF(F)
        Line Input #F, line
        arr = SplitCsvLine(line, delim)
        collected = collected + 1: cnt = cnt + 1
        For j = 1 To lo.ListColumns.Count
            If j <= UBound(arr) + 1 Then
                data(collected, j) = arr(j - 1)
            Else
                data(collected, j) = Empty
            End If
        Next
        If collected = block Then
            StepProgress cnt
            WriteArrayToListObjectChunked lo, data, startRow, block, "CSV書き込み"
            startRow = startRow + block
            collected = 0
            ReDim data(1 To block, 1 To lo.ListColumns.Count)
            Pulse "CSV読込中"
        End If
    Loop

    If collected > 0 Then
        Dim tail As Variant
        ReDim tail(1 To collected, 1 To lo.ListColumns.Count)
        For i = 1 To collected
            For j = 1 To lo.ListColumns.Count
                tail(i, j) = data(i, j)
            Next
        Next
        WriteArrayToListObjectChunked lo, tail, startRow, block, "CSV書き込み"
    End If

    Close #F
    EndProgress "CSV読込完了"
    Exit Sub
EH:
    On Error Resume Next
    Close #F
    EndProgress "CSV読込中断"
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Private Function DetectDelimiterFromTopLines(ByVal filePath As String) As String
    On Error GoTo EH
    Dim F As Integer: F = FreeFile
    Dim l As String
    Open filePath For Input As #F
    If Not EOF(F) Then
        Line Input #F, l
        If InStr(l, vbTab) > 0 Then DetectDelimiterFromTopLines = vbTab: GoTo Done
        If InStr(l, ";") > 0 Then DetectDelimiterFromTopLines = ";": GoTo Done
        If InStr(l, ",") > 0 Then DetectDelimiterFromTopLines = ",": GoTo Done
    End If
Done:
    Close #F
    Exit Function
EH:
    On Error Resume Next
    Close #F
End Function

Private Function SplitCsvLine(ByVal line As String, ByVal delim As String) As Variant
    Dim res() As String, i As Long, ch As String, inQ As Boolean
    ReDim res(0 To 0): res(0) = ""
    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)
        If ch = """" Then
            If inQ And i < Len(line) And Mid$(line, i + 1, 1) = """" Then
                res(UBound(res)) = res(UBound(res)) & """"
                i = i + 1
            Else
                inQ = Not inQ
            End If
        ElseIf ch = delim And Not inQ Then
            ReDim Preserve res(0 To UBound(res) + 1)
            res(UBound(res)) = ""
        Else
            res(UBound(res)) = res(UBound(res)) & ch
        End If
    Next
    SplitCsvLine = res
End Function

'================ ListObject 補助 ============================
Public Sub EnsureTableDataRows(ByVal lo As ListObject, ByVal needRows As Long)
    Dim cur As Long
    On Error GoTo EH
    cur = 0
    If Not lo.DataBodyRange Is Nothing Then cur = lo.DataBodyRange.Rows.Count
    If needRows > cur Then
        Dim addN As Long: addN = needRows - cur
        lo.ListRows.Add AlwaysInsert:=True, Count:=addN
    ElseIf needRows < cur Then
        Dim delN As Long: delN = cur - needRows
        Dim i As Long
        For i = 1 To delN
            lo.ListRows(lo.ListRows.Count).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub

Public Sub EnsureTableHeader(ByVal lo As ListObject, ByRef headers: Variant)
    Dim i As Long, needCols As Long, curCols As Long
    needCols = UBound(headers) + 1
    curCols = lo.ListColumns.Count
    If needCols > curCols Then
        For i = 1 To needCols - curCols
            lo.ListColumns.Add
        Next
    ElseIf needCols < curCols Then
        For i = curCols To needCols + 1 Step -1
            lo.ListColumns(i).Delete
        Next
    End If
    For i = 1 To needCols
        lo.ListColumns(i).Name = headers(i - 1)
    End If
End Sub

Public Sub FastClearTable(ByVal lo As ListObject)
    On Error GoTo EH
    If Not lo.DataBodyRange Is Nothing Then
        lo.DataBodyRange.ClearContents
        Dim r As Long
        For r = lo.ListRows.Count To 1 Step -1
            lo.ListRows(r).Delete
        Next
    End If
    Exit Sub
EH:
    Err.Raise Err.Number, Err.Source, Err.Description
End Sub
