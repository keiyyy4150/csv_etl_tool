‰ªª„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰∏çÂÖ∑ÂêàÔºàSEQ„ÅåÊîπË°å„Å´„Å™„ÇãÔºâ„ÇíËß£Ê∂à„Åó„Å§„Å§„ÄÅÂàóÁï™Âè∑„ÅÆ‰∫ãÂâç„Ç≠„É£„ÉÉ„Ç∑„É•ÔºãÈÖçÂàó„Ç≠„É£„ÉÉ„Ç∑„É•ÔºãSUMÂØæÂøúÔºãEvaluate„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºãÈ´òÈÄü„Éï„É©„Ç∞„Åæ„ÅßÂÖ®ÈÉ®ÂÖ•„Çä„ÅÆ‚Äú„Éï„É´Áâà‚Äù„Åß„Åô„ÄÇ
‰ª•‰∏ã„ÅÆ 2„É¢„Ç∏„É•„Éº„É´ „ÇíÂ∑Æ„ÅóÊõø„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

‚∏ª

üìÑ modPerf.basÔºà„Åù„ÅÆ„Åæ„ÅæË≤º„Çä‰ªò„ÅëÔºâ

Attribute VB_Name = "modPerf"
Option Explicit

Public Sub SpeedUpON()
    With Application
        .ScreenUpdating = False
        .EnableEvents = False
        .DisplayStatusBar = False
        .Calculation = xlCalculationManual
    End With
End Sub

Public Sub SpeedUpOFF()
    With Application
        .Calculation = xlCalculationAutomatic
        .ScreenUpdating = True
        .EnableEvents = True
        .DisplayStatusBar = True
        .StatusBar = False
    End With
End Sub


‚∏ª

üìÑ modJoinAndEval.basÔºà„Éï„É´ÂÆüË£Ö„ÉªÂÆåÂÖ®ÁâàÔºâ

Attribute VB_Name = "modJoinAndEval"
Option Explicit

' ============================================================
'  Êó¢Â≠ò„ÅÆÂ§ñÈÉ®‰æùÂ≠òÔºà‰ªñ„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©Ê∏à„ÅøÔºâ
'    - Map_TblNames() As String
'    - Map_OutCols()  As String
'    - Map_SrcCols(?, ?)  As Variant
'    - Map_Mode()     As String   ' "", "VALUE", "CONCAT", "EXPR" „Å™„Å©
'    - Map_DataType() As String   ' "", "NUMBER", "DATE"
'    - Map_IsKey()    As Boolean
'    - TableData(tbl As String) As Variant
'    - KeyIndexMulti(tbl As String) As Object ' key -> Collection(rowIdx)
'    - AllowOneToMany As Boolean
'    - m_baseTblName As String, m_baseRowIdx() As Long
' ============================================================

' ============================================================
'  ÂÆüË°åÊôÇ„Ç≠„É£„ÉÉ„Ç∑„É•ÔºàÈ´òÈÄüÂåñ„ÅÆË¶ÅÔºâ
' ============================================================
Public Cache_Built As Boolean
Public Cache_BaseTbl As String
Public Cache_ColIdx() As Variant     ' (outCol, t) ‚Üí Long() „ÅÆÈÖçÂàóÔºà„Åù„ÅÆÂàó„ÅßÂèÇÁÖß„Åô„ÇãÂàóÁï™Âè∑„ÅÆÈÖçÂàóÔºâ
Public Cache_DoJoin() As Boolean      ' Âàó„Åî„Å®„ÅÆ joinÔºàCONCAT „ÅÆ„Åø True„ÄÇKeyÂàó„ÅØÂøÖ„Åö FalseÔºâ
Public Cache_TblCount As Long

' TableData „ÅÆÁµêÊûú„ÇíÂ§öÈáçÂèÇÁÖß„Åó„Å™„ÅÑ„Åü„ÇÅ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
Private m_tblCache As Object               ' Scripting.Dictionary: tblName -> Variant(arr)
Private m_currentBaseTbl As String
Private m_currentBaseArr As Variant

'=============================================================
' Êï∞ÂÄ§Âåñ„ÉªÊñáÂ≠óÂàóÊ≠£Ë¶èÂåñ
'=============================================================
Private Function ToNumberOrZero(ByVal s As Variant) As String
    Dim t As String: t = Trim$(CStr(s))
    If Len(t) = 0 Then ToNumberOrZero = "0": Exit Function
    On Error Resume Next
    t = StrConv(t, vbNarrow)
    On Error GoTo 0
    t = Replace$(t, ",", "")
    t = Replace$(t, "Ôø•", ""): t = Replace$(t, "\", "")
    t = Replace$(t, "ÔºÖ", "%")
    If Right$(t, 1) = "%" Then
        t = Left$(t, Len(t) - 1)
        If IsNumeric(t) Then
            ToNumberOrZero = CStr(CDbl(t) / 100#)
        Else
            ToNumberOrZero = "0"
        End If
        Exit Function
    End If
    If IsNumeric(t) Then
        ToNumberOrZero = CStr(CDbl(t)) Else ToNumberOrZero = "0"
    End If
End Function

Private Function NumVal(ByVal s As String) As Double
    NumVal = CDbl(Val(ToNumberOrZero(s)))
End Function

Private Function NormalizeText(ByVal s As Variant) As String
    Dim t As String
    If IsNull(s) Then NormalizeText = "": Exit Function
    t = Trim$(CStr(s))
    On Error Resume Next
    t = StrConv(t, vbNarrow)
    On Error GoTo 0
    NormalizeText = t
End Function

Private Function NormalizeHeader(ByVal s As String) As String
    If Len(s) = 0 Then NormalizeHeader = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "") ' BOMÈô§Âéª
    NormalizeHeader = Trim$(s)
End Function

'=============================================================
' ÈÖçÂàó„Ç≠„É£„ÉÉ„Ç∑„É•
'=============================================================
Private Function GetTableArr(tbl As String) As Variant
    If m_tblCache Is Nothing Then Set m_tblCache = CreateObject("Scripting.Dictionary")
    If Not m_tblCache.Exists(tbl) Then
        m_tblCache(tbl) = TableData(tbl)
    End If
    GetTableArr = m_tblCache(tbl)
End Function

'=============================================================
' ÂàóÂêç/ÂàóÁï™Âè∑„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
'=============================================================
Private Function Norm(ByVal s As String) As String
    If Len(s) = 0 Then Norm = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "")
    Norm = Trim$(s)
End Function

Public Function FindColumnIndex(arr As Variant, ColName As String) As Long
    Dim c As Long, target As String
    target = Norm(ColName)
    For c = 1 To UBound(arr, 2)
        If Norm(CStr(arr(1, c))) = target Then FindColumnIndex = c: Exit Function
    Next
    FindColumnIndex = 0
End Function

Public Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then IndexOfTable = i: Exit Function
    Next
    IndexOfTable = -1
End Function

Private Function SafeGetSrcColName(i As Long, tIdx As Long) As String
    Dim lb1 As Long, ub1 As Long, lb2 As Long, ub2 As Long
    On Error GoTo FAIL
    lb1 = LBound(Map_SrcCols, 1): ub1 = UBound(Map_SrcCols, 1)
    lb2 = LBound(Map_SrcCols, 2): ub2 = UBound(Map_SrcCols, 2)
    Dim tAdj As Long
    If lb2 = 1 And LBound(Map_TblNames) = 0 Then tAdj = tIdx + 1 Else tAdj = tIdx
    If i < lb1 Or i > ub1 Then GoTo FAIL
    If tAdj < lb2 Or tAdj > ub2 Then GoTo FAIL
    Dim v As Variant: v = Map_SrcCols(i, tAdj)
    If IsError(v) Or IsNull(v) Then GoTo FAIL
    If IsArray(v) Then GoTo FAIL
    SafeGetSrcColName = Trim$(CStr(v))
    Exit Function
FAIL:
    SafeGetSrcColName = ""
End Function

Private Function SafeGetSrcColNames(i As Long, tIdx As Long) As Collection
    Dim col As New Collection, raw As String, s As String
    raw = SafeGetSrcColName(i, tIdx)
    If Len(raw) = 0 Then Set SafeGetSrcColNames = col: Exit Function
    s = Replace$(raw, vbCrLf, vbLf)
    s = Replace$(s, vbCr, vbLf)
    s = Replace$(s, "|", vbLf)
    Dim arr() As String, k As Long, one As String
    arr = Split(s, vbLf)
    For k = LBound(arr) To UBound(arr)
        one = NormalizeHeader(arr(k))
        If Len(one) > 0 Then col.Add one
    Next
    Set SafeGetSrcColNames = col
End Function

Public Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long, names As Collection
    tIdx = IndexOfTable(Map_TblNames, baseTbl)
    If tIdx < LBound(Map_TblNames) Then CollectKeyColIndexesForBase = Array(): Exit Function
    kc = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then If names.Count > 0 Then kc = kc + 1
        End If
    Next
    If kc = 0 Then CollectKeyColIndexesForBase = Array(): Exit Function

    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc): cur = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Dim picked As Long: picked = 0
            Dim j As Long, nm As String, ci As Long
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then
                For j = 1 To names.Count
                    nm = names(j)
                    If IsNumeric(nm) Then ci = CLng(nm) Else ci = FindColumnIndex(baseArr, nm)
                    If ci > 0 Then picked = ci: Exit For
                Next
                If picked > 0 Then cur = cur + 1: idx(cur) = picked
            End If
        End If
    Next
    CollectKeyColIndexesForBase = idx
End Function

'=============================================================
' ÂÆüË°åÊôÇ„Ç≠„É£„ÉÉ„Ç∑„É•ÔºàÂàóÁï™Âè∑ÔºÜjoinÂà§ÂÆöÔºâÊßãÁØâ
'=============================================================
Public Sub BuildRuntimeCache(baseTbl As String)
    Dim outColsCnt As Long: outColsCnt = UBound(Map_OutCols) - LBound(Map_OutCols) + 1
    Cache_BaseTbl = baseTbl
    Cache_TblCount = UBound(Map_TblNames) - LBound(Map_TblNames) + 1
    ReDim Cache_ColIdx(1 To outColsCnt, LBound(Map_TblNames) To UBound(Map_TblNames))
    ReDim Cache_DoJoin(1 To outColsCnt)

    ' Âàó„Åî„Å®„ÅÆ join Âà§ÂÆöÔºöCONCAT „ÅÆ„Åø True„ÄÅ„Ç≠„ÉºÂàó„ÅØÂøÖ„Åö False
    Dim c As Long
    For c = 1 To outColsCnt
        Cache_DoJoin(c) = (UCase$(Map_Mode(c)) = "CONCAT")
        If Map_IsKey(c) Then Cache_DoJoin(c) = False
    Next

    ' ÂêÑ„ÉÜ„Éº„Éñ„É´„ÅÆÈÖçÂàóÔºà1Âõû„Å†„ÅëÂèñÂæóÔºâ
    Dim t As Long, arr As Variant
    Dim tblArr() As Variant
    ReDim tblArr(LBound(Map_TblNames) To UBound(Map_TblNames))
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        tblArr(t) = GetTableArr(Map_TblNames(t))
    Next

    ' (Âàó√ó„ÉÜ„Éº„Éñ„É´) „ÅßÂèÇÁÖß„Åô„ÇãÂàóÁï™Âè∑„ÅÆÈÖçÂàó„Çí‰∫ãÂâç„Å´Á¢∫ÂÆö
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        For c = 1 To outColsCnt
            Dim names As Collection: Set names = SafeGetSrcColNames(c, t)
            If Not names Is Nothing And names.Count > 0 Then
                Dim idxs() As Long, k As Long, nm As String, ci As Long, picked As Long
                arr = tblArr(t)
                ReDim idxs(1 To names.Count): picked = 0
                For k = 1 To names.Count
                    nm = names(k)
                    If IsNumeric(nm) Then ci = CLng(nm) Else ci = FindColumnIndex(arr, nm)
                    If ci > 0 Then picked = picked + 1: idxs(picked) = ci
                Next
                If picked > 0 Then
                    ReDim Preserve idxs(1 To picked)
                    Cache_ColIdx(c, t) = idxs
                Else
                    Cache_ColIdx(c, t) = Empty
                End If
            Else
                Cache_ColIdx(c, t) = Empty
            End If
        Next
    Next

    Cache_Built = True
End Sub

'=============================================================
' 1ÂØæÂ§öÊôÇ„ÅÆÊúÄÂ§ßÂ¢óÂπÖ
'=============================================================
Private Function MaxMatchesForKey(ByVal keyStr As String, baseTbl As String) As Long
    Dim t As Long, m As Long: m = 0
    If (Not Not Map_TblNames) = 0 Then MaxMatchesForKey = 1: Exit Function
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        Dim nm As String: nm = Map_TblNames(t)
        If nm = baseTbl Then
            If m < 1 Then m = 1
        Else
            Dim kd As Object: Set kd = KeyIndexMulti(nm)
            If Not kd Is Nothing Then
                If kd.Exists(keyStr) Then
                    If kd(keyStr).Count > m Then m = kd(keyStr).Count
                End If
            End If
        End If
    Next
    If m < 1 Then m = 1
    MaxMatchesForKey = m
End Function

'=============================================================
' È´òÈÄüÁâàÔºöVALUE/CONCAT rawÂèñÂæóÔºàÂàóÁï™Âè∑„Ç≠„É£„ÉÉ„Ç∑„É•Âà©Áî®Ôºâ
'=============================================================
Public Function BuildValueModeRaw_Fast(colIndex As Long, baseTbl As String, baseRow As Long, myKey As String, _
                                       Optional matchIndex As Long = 1) As String
    Dim t As Long, arr As Variant, idxs As Variant, acc As String, v As String
    Dim doJoin As Boolean: doJoin = Cache_DoJoin(colIndex)

    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        idxs = Cache_ColIdx(colIndex, t)
        If IsEmpty(idxs) Then GoTo CONT_T

        If Map_TblNames(t) = baseTbl Then
            If m_currentBaseTbl = baseTbl Then
                arr = m_currentBaseArr
            Else
                arr = GetTableArr(baseTbl)
            End If
            Dim k As Long
            For k = LBound(idxs) To UBound(idxs)
                v = CStr(arr(baseRow, idxs(k)))
                If doJoin Then
                    If Len(v) > 0 Then
                        If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
                    End If
                Else
                    If Len(v) > 0 Then BuildValueModeRaw_Fast = v: Exit Function
                End If
            Next
        Else
            Dim k2 As Long
            For k2 = LBound(idxs) To UBound(idxs)
                ' ‰ªñ„ÉÜ„Éº„Éñ„É´„ÅØ„Ç≠„Éº„ÅßÂºï„ÅÑ„Å¶ kÁï™ÁõÆ„ÅÆ‰∏ÄËá¥
                v = GetValueFromTableMulti(Map_TblNames(t), CStr(idxs(k2)), myKey, matchIndex)
                If doJoin Then
                    If Len(v) > 0 Then
                        If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
                    End If
                Else
                    If Len(v) > 0 Then BuildValueModeRaw_Fast = v: Exit Function
                End If
            Next
        End If
CONT_T:
    Next
    BuildValueModeRaw_Fast = acc
End Function

'=============================================================
' JOIN Ê∏à„ÅøÁÑ°Âä†Â∑•ÈÖçÂàó„ÅÆÊßãÁØâÔºàList„ÅØ1ÂØæÂ§öÂ¢óÂπÖÔºâ
'=============================================================
Public Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim outColsCnt As Long: outColsCnt = UBound(Map_OutCols) - LBound(Map_OutCols) + 1

    If Len(baseTbl) = 0 Then
        Dim emptyArr() As Variant: ReDim emptyArr(1 To 1, 1 To outColsCnt)
        BuildJoinedRaw = emptyArr: Exit Function
    End If

    ' „Ç≠„É£„ÉÉ„Ç∑„É•ÊßãÁØâ
    If Not Cache_Built Or Cache_BaseTbl <> baseTbl Then BuildRuntimeCache baseTbl

    ' „Éô„Éº„ÇπÈÖçÂàó„Çí‰∏ÄÂ∫¶„Å†„ÅëÊé¥„ÇÄ
    Dim baseArr As Variant
    baseArr = GetTableArr(baseTbl)
    m_currentBaseTbl = baseTbl
    m_currentBaseArr = baseArr

    Dim baseKeyCols() As Long
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)

    ' Ë°åÊï∞Ë¶ãÁ©ç
    Dim totalRows As Long, r As Long, expand As Long, myKey As String
    totalRows = 0
    For r = 2 To UBound(baseArr, 1)
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        expand = 1
        If AllowOneToMany Then
            expand = MaxMatchesForKey(myKey, baseTbl)
            If expand < 1 Then expand = 1
        End If
        totalRows = totalRows + expand
    Next
    If totalRows = 0 Then
        Dim empty2() As Variant: ReDim empty2(1 To 1, 1 To outColsCnt)
        BuildJoinedRaw = empty2: Exit Function
    End If

    ' Âá∫ÂäõÈÖçÂàó
    Dim result() As Variant
    ReDim result(1 To totalRows, 1 To outColsCnt)
    ReDim m_baseRowIdx(1 To totalRows)

    ' ÂÆü„Éá„Éº„ÇøÂüã„ÇÅÔºàÈ´òÈÄüÁâàÔºâ
    Dim outRow As Long, c As Long, k As Long
    outRow = 0
    For r = 2 To UBound(baseArr, 1)
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        expand = 1
        If AllowOneToMany Then
            expand = MaxMatchesForKey(myKey, baseTbl)
            If expand < 1 Then expand = 1
        End If

        For k = 1 To expand
            outRow = outRow + 1
            m_baseRowIdx(outRow) = r
            For c = 1 To outColsCnt
                result(outRow, c) = BuildValueModeRaw_Fast(c, baseTbl, r, myKey, k)
            Next c
        Next k

        ' ÂøúÁ≠î„Å™„ÅóÂõûÈÅøÔºà‰ΩìÊÑü„Éï„É™„Éº„Ç∫ÂØæÁ≠ñÔºâ
        If (outRow Mod 100) = 0 Then DoEvents
    Next r

    BuildJoinedRaw = result
End Function

'=============================================================
' ‰ªñ„ÉÜ„Éº„Éñ„É´„Åã„Çâ kÁï™ÁõÆ‰∏ÄËá¥„ÇíÂèñÂæó
'=============================================================
Public Function GetValueFromTableMulti(tbl As String, col As String, keyStr As String, matchIndex As Long) As String
    On Error GoTo SAFE
    Dim kd As Object: Set kd = KeyIndexMulti(tbl)
    If kd Is Nothing Then Exit Function
    If Not kd.Exists(keyStr) Then Exit Function

    Dim arr As Variant: arr = GetTableArr(tbl)
    Dim ci As Long
    If IsNumeric(col) Then ci = CLng(col) Else ci = FindColumnIndex(arr, col)
    If ci = 0 Then Exit Function

    If kd(keyStr).Count >= matchIndex Then
        GetValueFromTableMulti = CStr(arr(kd(keyStr)(matchIndex), ci))
    End If
    Exit Function
SAFE:
    GetValueFromTableMulti = ""
End Function

'=============================================================
' „ÉÜ„É≥„Éó„É¨ÁΩÆÊèõÔºàÊñáÂ≠óÂàóÔºâ
'=============================================================
Public Function ApplyTemplate(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                              ByVal processed As Boolean, Optional outColIndex As Long = -1) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        If processed Then
            valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        Else
            valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ApplyTemplate = Replace(s, """", "")
End Function

'=============================================================
' „Éà„Éº„ÇØ„É≥Ëß£Ê±∫Ôºàraw / processedÔºâ
'=============================================================
Private Function ResolveTokenRawWithIndex(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                          ByVal matchIndex As Long) As String
    Dim t As String, c As String, p As Long
    token = Replace(Replace(token, "{", ""), "}", "")
    p = InStr(token, ".")
    If p = 0 Then Exit Function
    t = Left$(token, p - 1): c = Mid$(token, p + 1)
    If t = baseTbl Then
        Dim arr As Variant, ci As Long
        If m_currentBaseTbl = baseTbl Then
            arr = m_currentBaseArr
        Else
            arr = GetTableArr(t)
        End If
        If IsNumeric(c) Then ci = CLng(c) Else ci = FindColumnIndex(arr, c)
        If ci > 0 Then ResolveTokenRawWithIndex = CStr(arr(baseRow, ci))
    Else
        ResolveTokenRawWithIndex = GetValueFromTableMulti(t, c, myKey, matchIndex)
    End If
End Function

Public Function ResolveTokenRaw(token As String, baseTbl As String, baseRow As Long, myKey As String) As String
    ResolveTokenRaw = ResolveTokenRawWithIndex(token, baseTbl, baseRow, myKey, 1)
End Function

Public Function ResolveTokenProcessed(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                      Optional outColIndex As Long = -1) As String
    Dim raw As Variant
    raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
    If outColIndex <= 0 Then
        ResolveTokenProcessed = CStr(raw)
    Else
        ResolveTokenProcessed = ApplyOneValueTransform(raw, Map_DataType(outColIndex))
    End If
End Function

'=============================================================
' IF ÊßãÊñáÁæ§
'=============================================================
Private Function HasIFSyntax(ByVal s As String) As Boolean
    s = UCase$(s)
    HasIFSyntax = (Left$(s, 3) = "IF(") Or (Left$(s, 6) = "IFALL(") Or (Left$(s, 6) = "IFANY(")
End Function

Private Function EvalIFLine(ByVal line As String, baseTbl As String, baseRow As Long, myKey As String, _
                            ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim pOpen As Long, pClose As Long, fn As String, inside As String
    pOpen = InStr(line, "("): pClose = InStrRev(line, ")")
    If pOpen = 0 Or pClose = 0 Or pClose <= pOpen Then Exit Function
    fn = UCase$(Left$(line, pOpen - 1))
    inside = Mid$(line, pOpen + 1, pClose - pOpen - 1)

    Dim args As Collection: Set args = SplitArgs(inside)
    If args.Count < 3 Then Exit Function

    Dim thenText As String, elseText As String
    thenText = StripQuotes(args(args.Count - 1))
    elseText  = StripQuotes(args(args.Count))

    Dim ok As Boolean
    Select Case fn
        Case "IF":    ok = EvalOneCondition(args(1), baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFALL": ok = EvalAllConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFANY": ok = EvalAnyConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case Else:    ok = False
    End Select

    If ok Then
        EvalIFLine = ApplyTemplate(thenText, baseTbl, baseRow, myKey, processed, outColIndex)
    Else
        EvalIFLine = ApplyTemplate(elseText,  baseTbl, baseRow, myKey, processed, outColIndex)
    End If
End Function

Private Function EvalAllConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If Not EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAllConditions = False: Exit Function
        End If
    Next
    EvalAllConditions = True
End Function

Private Function EvalAnyConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAnyConditions = True: Exit Function
        End If
    Next
    EvalAnyConditions = False
End Function

Private Function EvalOneCondition(cond As String, baseTbl As String, baseRow As Long, myKey As String, _
                                  ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim p As Long, leftExpr As String, rightExpr As String
    Dim actual As String, expected As String, u As String
    cond = Trim$(cond): u = UCase$(cond)

    ' LIKE({..},"A*")
    If Left$(u, 5) = "LIKE(" And Right$(u, 1) = ")" Then
        Dim inside As String, a As Collection
        inside = Mid$(cond, 6, Len(cond) - 6)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            actual = GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(a(2))
            EvalOneCondition = (actual Like expected)
            Exit Function
        End If
    End If

    ' STARTSWITH/ENDSWITH/CONTAINS
    If Left$(u, 11) = "STARTSWITH" Or Left$(u, 9) = "ENDSWITH" Or Left$(u, 8) = "CONTAINS" Then
        Dim fn As String, ins As String, a2 As Collection
        fn = Left$(cond, InStr(cond, "(") - 1)
        ins = Mid$(cond, InStr(cond, "(") + 1, Len(cond) - InStr(cond, "(") - 1)
        Set a2 = SplitArgs(ins)
        If a2.Count = 2 Then
            actual = GetScalarValue(a2(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(a2(2))
            Select Case UCase$(fn)
                Case "STARTSWITH": EvalOneCondition = (Left$(actual, Len(expected)) = expected)
                Case "ENDSWITH":   EvalOneCondition = (Right$(actual, Len(expected)) = expected)
                Case "CONTAINS":   EvalOneCondition = (InStr(1, actual, expected, vbTextCompare) > 0)
            End Select
            Exit Function
        End If
    End If

    ' A = B
    p = InStr(cond, "=")
    If p = 0 Then EvalOneCondition = False: Exit Function
    leftExpr = Trim$(Left$(cond, p - 1))
    rightExpr = Trim$(Mid$(cond, p + 1))
    actual = GetScalarValue(leftExpr, baseTbl, baseRow, myKey, processed, outColIndex)
    expected = NormalizeText(StripQuotes(rightExpr))
    EvalOneCondition = (actual = expected)
End Function

'=============================================================
' GetScalarValueÔºàLEFT/RIGHT/MID/LEN + {tbl.col}Ôºâ
'=============================================================
Private Function GetScalarValue(expr As String, baseTbl As String, baseRow As Long, myKey As String, _
                                ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim u As String: u = UCase$(Trim$(expr))
    Dim inside As String, a As Collection
    If Left$(u, 5) = "LEFT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 6, Len(expr) - 6)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s As String, n As Long
            s = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n = CLng(Val(a(2)))
            GetScalarValue = Left$(s, n): Exit Function
        End If
    ElseIf Left$(u, 6) = "RIGHT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 7, Len(expr) - 7)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s2 As String, n2 As Long
            s2 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n2 = CLng(Val(a(2)))
            GetScalarValue = Right$(s2, n2): Exit Function
        End If
    ElseIf Left$(u, 4) = "MID(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Set a = SplitArgs(inside)
        If a.Count = 3 Then
            Dim s3 As String, st As Long, ln As Long
            s3 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            st = CLng(Val(a(2))): ln = CLng(Val(a(3)))
            GetScalarValue = Mid$(s3, st, ln): Exit Function
        End If
    ElseIf Left$(u, 4) = "LEN(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Dim s4 As String: s4 = NormalizeText(GetScalarValue(inside, baseTbl, baseRow, myKey, processed, outColIndex))
        GetScalarValue = CStr(Len(s4)): Exit Function
    End If

    Dim raw As String
    If processed Then raw = ResolveTokenProcessed(expr, baseTbl, baseRow, myKey, outColIndex) _
                    Else raw = ResolveTokenRaw(expr, baseTbl, baseRow, myKey)
    GetScalarValue = NormalizeText(raw)
End Function

'=============================================================
' ÊñáÂ≠óÂàó„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
'=============================================================
Private Function StripQuotes(ByVal s As String) As String
    s = Trim$(s)
    If (Left$(s, 1) = "'" And Right$(s, 1) = "'") Or (Left$(s, 1) = """" And Right$(s, 1) = """") Then
        StripQuotes = Mid$(s, 2, Len(s) - 2)
    Else
        StripQuotes = s
    End If
End Function

Private Function SplitArgs(ByVal s As String) As Collection
    Dim col As New Collection
    Dim i As Long, ch As String * 1, inQ As Boolean, qChar As String * 1, buf As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch = """" Or ch = "'" Then
            If inQ Then
                If ch = qChar Then inQ = False
            Else
                inQ = True: qChar = ch
            End If
            buf = buf & ch
        ElseIf ch = "," And Not inQ Then
            col.Add Trim$(buf): buf = ""
        Else
            buf = buf & ch
        End If
    Next
    If Len(buf) > 0 Or s = "" Then col.Add Trim$(buf)
    Set SplitArgs = col
End Function

Public Function SplitDefToParts(ByVal def As String) As Collection
    Dim col As New Collection, tmp As String
    tmp = Replace$(def, vbCr, "")
    tmp = Replace$(tmp, "|", vbLf)
    Dim arr() As String, i As Long
    arr = Split(tmp, vbLf)
    For i = LBound(arr) To UBound(arr)
        If Trim$(arr(i)) <> "" Then col.Add Trim$(arr(i))
    Next
    Set SplitDefToParts = col
End Function

Public Function SplitExprToLines(ByVal def As String) As Collection
    Set SplitExprToLines = SplitDefToParts(def)
End Function

'=============================================================
' EXPRÔºöSUM(‚Ä¶)
'=============================================================
Private Function EvalSUM(ByVal line As String, baseTbl As String, baseRow As Long, myKey As String, _
                         ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim inside As String, args As Collection, i As Long, v As String, total As Double
    inside = Mid$(line, 5, Len(line) - 5)
    Set args = SplitArgs(inside)
    For i = 1 To args.Count
        v = GetScalarValue(args(i), baseTbl, baseRow, myKey, processed, outColIndex)
        total = total + NumVal(v)
    Next
    EvalSUM = CStr(total)
End Function

'=============================================================
' EXPR Ë©ï‰æ°ÔºàIF/„ÉÜ„É≥„Éó„É¨/ÂºèÔºâ
'=============================================================
Public Function EvaluateExpr(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                             ByVal processed As Boolean, Optional outColIndex As Long = -1) As Variant
    Dim lines As Collection: Set lines = SplitExprToLines(def)
    Dim i As Long, one As String, res As String, acc As String

    For i = 1 To lines.Count
        one = Trim$(lines(i))
        If one = "" Then GoTo CONT

        If HasIFSyntax(one) Then
            res = EvalIFLine(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        ElseIf InStr(one, """") > 0 Or InStr(one, "'") > 0 Then
            res = ApplyTemplate(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        Else
            Dim up As String: up = UCase$(one)
            If Left$(up, 4) = "SUM(" And Right$(up, 1) = ")" Then
                res = EvalSUM(one, baseTbl, baseRow, myKey, processed, outColIndex)
            Else
                Dim expr As String, v As Variant
                If processed Then expr = ReplaceTokensProcessedAsNumber(one, baseTbl, baseRow, myKey, outColIndex) _
                              Else expr = ReplaceTokensWithRaw(one, baseTbl, baseRow, myKey)
                ' Application.Evaluate „Çí„Åæ„ÅöË©¶„Åô
                On Error Resume Next
                v = Application.Evaluate("=" & expr)
                On Error GoTo 0
                If IsError(v) Or VarType(v) = vbError Or IsEmpty(v) Then
                    res = CStr(SafeEval(expr))
                Else
                    res = CStr(v)
                End If
            End If
            If acc = "" Then acc = res Else acc = acc & vbLf & res
        End If
CONT:
    Next

    If processed And outColIndex > 0 Then
        EvaluateExpr = FinalizeByType(acc, Map_DataType(outColIndex))
    Else
        EvaluateExpr = acc
    End If
End Function

'=============================================================
' Êï∞Âºè„Éà„Éº„ÇØ„É≥ÁΩÆÊèõÔºàÈùûÊï∞ÂÄ§‚Üí0Ôºâ
'=============================================================
Public Function ReplaceTokensWithRaw(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        valStr = ToNumberOrZero(valStr)
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensWithRaw = s
End Function

Public Function ReplaceTokensProcessedAsNumber(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        valStr = ToNumberOrZero(valStr)
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensProcessedAsNumber = s
End Function

'=============================================================
' Evaluate „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºöÁ∞°ÊòìÂõõÂâáÊºîÁÆó
'=============================================================
Public Function SafeEval(ByVal expr As String) As Double
    On Error GoTo FAIL
    expr = Replace$(expr, " ", "")
    expr = Replace$(expr, vbCr, "")
    expr = Replace$(expr, vbLf, "")
    expr = Replace$(expr, vbTab, "")
    If Len(expr) = 0 Then SafeEval = 0: Exit Function

    Dim nums() As Double, ops() As String, nTop As Long, oTop As Long
    ReDim nums(1 To 1): ReDim ops(1 To 1)
    nTop = 0: oTop = 0

    Dim prevKind As Integer: prevKind = 0 ' 0:ÈñãÂßã,1:Êï∞ÂÄ§/")",2:ÊºîÁÆóÂ≠ê/"("
    Dim i As Long, ch As String, num As String

    i = 1
    Do While i <= Len(expr)
        ch = Mid$(expr, i, 1)
        If ch Like "[0-9.]" Then
            num = ""
            Do While i <= Len(expr)
                ch = Mid$(expr, i, 1)
                If ch Like "[0-9.]" Then num = num & ch: i = i + 1 Else Exit Do
            Loop
            nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
            nums(nTop) = CDbl(Val(num))
            prevKind = 1
            GoTo NEXTITER

        ElseIf ch = "(" Then
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2

        ElseIf ch = ")" Then
            Do While oTop > 0
                If ops(oTop) = "(" Then oTop = oTop - 1: Exit Do
                ApplyOp nums, nTop, ops, oTop
            Loop
            prevKind = 1

        ElseIf ch = "+" Or ch = "-" Or ch = "*" Or ch = "/" Then
            If ch = "-" And (prevKind = 0 Or prevKind = 2) Then
                nTop = nTop + 1: ReDim Preserve nums(1 To nTop): nums(nTop) = 0
            Else
                Do While oTop > 0 And Precedence(ops(oTop)) >= Precedence(ch)
                    ApplyOp nums, nTop, ops, oTop
                Loop
            End If
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2
        End If
        i = i + 1
NEXTITER:
    Loop

    Do While oTop > 0
        ApplyOp nums, nTop, ops, oTop
    Loop
    If nTop > 0 Then SafeEval = nums(nTop) Else SafeEval = 0
    Exit Function
FAIL:
    SafeEval = 0
End Function

Private Function Precedence(op As String) As Long
    Select Case op
        Case "+", "-": Precedence = 1
        Case "*", "/": Precedence = 2
        Case Else:     Precedence = 0
    End Select
End Function

Private Sub ApplyOp(ByRef nums() As Double, ByRef nTop As Long, ByRef ops() As String, ByRef oTop As Long)
    If oTop <= 0 Or nTop < 2 Then Exit Sub
    Dim b As Double, a As Double, op As String, res As Double
    b = nums(nTop): nTop = nTop - 1
    a = nums(nTop)
    op = ops(oTop): oTop = oTop - 1
    Select Case op
        Case "+": res = a + b
        Case "-": res = a - b
        Case "*": res = a * b
        Case "/": If b = 0 Then res = 0 Else res = a / b
        Case Else: res = b
    End Select
    nums(nTop) = res
End Sub

'=============================================================
' EXPRÊúÄÁµÇÂûã„ÅÆÊï¥ÂΩ¢ÔºàNUMBER„ÅØÊîπË°åÂêàÁÆóÔºâ
'=============================================================
Private Function FinalizeByType(ByVal s As String, ByVal dataType As String) As String
    Select Case UCase$(dataType)
        Case "NUMBER"
            If Len(s) = 0 Then
                FinalizeByType = ""
            Else
                Dim total As Double, arr() As String, i As Long, one As String
                s = Replace$(Replace$(s, vbCrLf, vbLf), vbCr, vbLf)
                arr = Split(s, vbLf)
                For i = LBound(arr) To UBound(arr)
                    one = Trim$(arr(i))
                    If Len(one) > 0 Then total = total + CDbl(Val(ToNumberOrZero(one)))
                Next
                FinalizeByType = CStr(CLng(total))
            End If
        Case "DATE"
            If Len(s) = 0 Then FinalizeByType = "" _
            ElseIf IsDate(s) Then FinalizeByType = Format$(CDate(s), "yyyy/mm/dd") _
            Else FinalizeByType = ""
        Case Else
            FinalizeByType = s
    End Select
End Function

'=============================================================
' ÂçòÂÄ§„ÅÆÂûãÂ§âÊèõ„ÅÆ„Åø
'=============================================================
Public Function ApplyOneValueTransform(v As Variant, dataType As String) As String
    Dim w As Variant: w = v
    Select Case UCase$(dataType)
        Case "NUMBER": If Len(CStr(w)) > 0 And IsNumeric(w) Then w = CLng(w) Else w = ""
        Case "DATE":   If Len(CStr(w)) > 0 And IsDate(w) Then w = Format$(CDate(w), "yyyy/mm/dd") Else w = ""
        Case Else:     w = CStr(w)
    End Select
    ApplyOneValueTransform = CStr(w)
End Function

'=============================================================
' Â§âÊèõÊú¨‰ΩìÔºàEXPR ‰ª•Â§ñ„ÅØÊúÄÁü≠„Éë„ÇπÔºâ
'=============================================================
Public Function ApplyTransformSmart(src As Variant) As Variant
    Dim rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    Dim dst() As Variant: ReDim dst(1 To rows, 1 To cols)

    Dim r As Long, c As Long
    For r = 1 To rows
        For c = 1 To cols
            Select Case UCase$(Map_Mode(c))
                Case "EXPR"
                    dst(r, c) = EvaluateExpr(Map_Def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), True, c)
                Case "CONCAT"
                    ' ÊñáÂ≠óÈÄ£ÁµêÂàó„ÅØ BuildValueModeRaw_Fast „ÅßÊîπË°åÈÄ£ÁµêÊ∏à„Åø ‚Üí ÂûãÂ§âÊèõ„ÅÆ„Åø
                    dst(r, c) = ApplyOneValueTransform(src(r, c), Map_DataType(c))
                Case Else
                    dst(r, c) = ApplyOneValueTransform(src(r, c), Map_DataType(c))
            End Select
        Next
        If (r Mod 200) = 0 Then DoEvents
    Next
    ApplyTransformSmart = dst
End Function

Private Function GetKeyForRow(r As Long) As String
    Dim baseArr As Variant, baseKeyCols() As Long
    If Len(m_baseTblName) = 0 Then Exit Function
    baseArr = GetTableArr(m_baseTblName)
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, m_baseTblName)
    GetKeyForRow = BuildKeyFromRow(baseArr, m_baseRowIdx(r), baseKeyCols)
End Function


‚∏ª

ÈÅ©Áî®„Éù„Ç§„É≥„ÉàÔºàÈáçË¶ÅÔºâ
	‚Ä¢	SEQ „ÅåÊîπË°å„Å´„Å™„ÇãÂïèÈ°åÔºö
	‚Ä¢	Cache_DoJoin(c) = (Map_Mode(c) = "CONCAT") + If Map_IsKey(c) Then False „Åß„ÄÅ„Ç≠„ÉºÂàó„ÅØÂøÖ„ÅöÂçòÂÄ§„ÄÅCONCAT Âàó„Å†„ÅëÊîπË°åÈÄ£Áµê„Å´„Å™„Çä„Åæ„Åô„ÄÇ
	‚Ä¢	BuildJoinedRaw „ÅØ BuildValueModeRaw_Fast „Çí‰ΩøÁî®ÔºàforceJoinMultiple „ÅØ‰∏çË¶ÅÔºâ„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
	‚Ä¢	100‰ª∂Ë∂Ö„ÅßÂõ∫„Åæ„ÇãÔºö
	‚Ä¢	TableData „ÅÆÈÖçÂàó„Çí GetTableArr „Åß„Ç≠„É£„ÉÉ„Ç∑„É•„Åó„Å¶ÂÜçÂà©Áî®Ôºà„Éô„Éº„Çπ/‰ªñ„ÉÜ„Éº„Éñ„É´„Å®„ÇÇÔºâ„ÄÇ
	‚Ä¢	ÂàóÁï™Âè∑„Çí BuildRuntimeCache „Åß‰∫ãÂâçÁ¢∫ÂÆö„Åó„ÄÅ„Çª„É´„Åî„Å®„Å´ÂàóÂêç‚ÜíÂàóÁï™Âè∑Ê§úÁ¥¢„Çí„Åó„Åæ„Åõ„Çì„ÄÇ
	‚Ä¢	100Ë°å/200Ë°å„Åî„Å®„Å´ DoEvents „ÇíÂÖ•„Çå„Å¶‚ÄúÂøúÁ≠î„Å™„Åó‚Äù„ÇíÂõûÈÅø„ÄÇ
	‚Ä¢	Âá¶ÁêÜÂÖ•Âè£/Âá∫Âè£„Åß SpeedUpON/OFF „ÇíÂøÖ„ÅöÂëº„Çì„Åß„Åè„Å†„Åï„ÅÑÔºàImport/Process/Export „Åô„Åπ„Å¶Ôºâ„ÄÇ
	‚Ä¢	ÂêàÁÆó„Åå 0 „Å´„Å™„ÇãÔºö
	‚Ä¢	Definitions „Åß SUM(...) „Åå‰Ωø„Åà„Åæ„Åô„ÄÇ
	‚Ä¢	„Åù„Çå‰ª•Â§ñ„ÅÆÂõõÂâáÊºîÁÆó„ÅØ Application.Evaluate("=" & expr) ‚Üí Â§±ÊïóÊôÇ SafeEval „ÅÆÈ†Ü„Å´Ë©ï‰æ°„ÄÇ
	‚Ä¢	Êï∞ÂÄ§Âûã„ÅÆÊúÄÁµÇÊï¥ÂΩ¢„ÅØ ÊîπË°å„Åî„Å®ÂêàÁÆóÔºàFinalizeByTypeÔºâ„Å´„ÄÇ

‚∏ª

ÂøÖË¶Å„Å™„Çâ„ÄÅ„Åì„ÅÆ‰∏ä„Åß„Äå„Ç´„É≥„ÉûÂå∫Âàá„Çä„ÅÆ JOINÔºà‰æãÔºöJOIN(", ")Ôºâ„Äç„ÇÑ„ÄÅ‚ë¢„ÅÆÊ≠£Ë¶èÂåñÔºà‚ÄúA-1‚Äù „Å´Áµ±‰∏ÄÔºâ„Éá„Ç£„É¨„ÇØ„ÉÜ„Ç£„Éñ„ÇÇÊã°Âºµ„Åß„Åç„Åæ„Åô„ÄÇ„Åæ„Åö„ÅØ„Åì„ÅÆ„Éï„É´Áâà„ÅßSEQ„ÅÆÂçòÂÄ§Âåñ„Å®„Ç§„É≥„Éù„Éº„Éà„ÅÆÈÄüÂ∫¶/ÂÆâÂÆö„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ