ä»»ã›ã¦ãã ã•ã„ã€‚
ä¸å…·åˆï¼ˆSEQãŒæ”¹è¡Œã«ãªã‚‹ï¼‰ã‚’è§£æ¶ˆã—ã¤ã¤ã€åˆ—ç•ªå·ã®äº‹å‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‹é…åˆ—ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‹SUMå¯¾å¿œï¼‹Evaluateãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‹é«˜é€Ÿãƒ•ãƒ©ã‚°ã¾ã§å…¨éƒ¨å…¥ã‚Šã®â€œãƒ•ãƒ«ç‰ˆâ€ã§ã™ã€‚
ä»¥ä¸‹ã® 2ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« ã‚’å·®ã—æ›¿ãˆã¦ãã ã•ã„ã€‚

â¸»

ğŸ“„ modPerf.basï¼ˆãã®ã¾ã¾è²¼ã‚Šä»˜ã‘ï¼‰

Attribute VB_Name = "modPerf"
Option Explicit

Public Sub SpeedUpON()
    With Application
        .ScreenUpdating = False
        .EnableEvents = False
        .DisplayStatusBar = False
        .Calculation = xlCalculationManual
    End With
End Sub

Public Sub SpeedUpOFF()
    With Application
        .Calculation = xlCalculationAutomatic
        .ScreenUpdating = True
        .EnableEvents = True
        .DisplayStatusBar = True
        .StatusBar = False
    End With
End Sub


â¸»

ğŸ“„ modJoinAndEval.basï¼ˆãƒ•ãƒ«å®Ÿè£…ãƒ»å®Œå…¨ç‰ˆï¼‰

Attribute VB_Name = "modJoinAndEval"
Option Explicit

' ============================================================
'  æ—¢å­˜ã®å¤–éƒ¨ä¾å­˜ï¼ˆä»–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å®šç¾©æ¸ˆã¿ï¼‰
'    - Map_TblNames() As String
'    - Map_OutCols()  As String
'    - Map_SrcCols(?, ?)  As Variant
'    - Map_Mode()     As String   ' "", "VALUE", "CONCAT", "EXPR" ãªã©
'    - Map_DataType() As String   ' "", "NUMBER", "DATE"
'    - Map_IsKey()    As Boolean
'    - TableData(tbl As String) As Variant
'    - KeyIndexMulti(tbl As String) As Object ' key -> Collection(rowIdx)
'    - AllowOneToMany As Boolean
'    - m_baseTblName As String, m_baseRowIdx() As Long
' ============================================================

' ============================================================
'  å®Ÿè¡Œæ™‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆé«˜é€ŸåŒ–ã®è¦ï¼‰
' ============================================================
Public Cache_Built As Boolean
Public Cache_BaseTbl As String
Public Cache_ColIdx() As Variant     ' (outCol, t) â†’ Long() ã®é…åˆ—ï¼ˆãã®åˆ—ã§å‚ç…§ã™ã‚‹åˆ—ç•ªå·ã®é…åˆ—ï¼‰
Public Cache_DoJoin() As Boolean      ' åˆ—ã”ã¨ã® joinï¼ˆCONCAT ã®ã¿ Trueã€‚Keyåˆ—ã¯å¿…ãš Falseï¼‰
Public Cache_TblCount As Long

' TableData ã®çµæœã‚’å¤šé‡å‚ç…§ã—ãªã„ãŸã‚ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
Private m_tblCache As Object               ' Scripting.Dictionary: tblName -> Variant(arr)
Private m_currentBaseTbl As String
Private m_currentBaseArr As Variant

'=============================================================
' æ•°å€¤åŒ–ãƒ»æ–‡å­—åˆ—æ­£è¦åŒ–
'=============================================================
Private Function ToNumberOrZero(ByVal s As Variant) As String
    Dim t As String: t = Trim$(CStr(s))
    If Len(t) = 0 Then ToNumberOrZero = "0": Exit Function
    On Error Resume Next
    t = StrConv(t, vbNarrow)
    On Error GoTo 0
    t = Replace$(t, ",", "")
    t = Replace$(t, "ï¿¥", ""): t = Replace$(t, "\", "")
    t = Replace$(t, "ï¼…", "%")
    If Right$(t, 1) = "%" Then
        t = Left$(t, Len(t) - 1)
        If IsNumeric(t) Then
            ToNumberOrZero = CStr(CDbl(t) / 100#)
        Else
            ToNumberOrZero = "0"
        End If
        Exit Function
    End If
    If IsNumeric(t) Then
        ToNumberOrZero = CStr(CDbl(t)) Else ToNumberOrZero = "0"
    End If
End Function

Private Function NumVal(ByVal s As String) As Double
    NumVal = CDbl(Val(ToNumberOrZero(s)))
End Function

Private Function NormalizeText(ByVal s As Variant) As String
    Dim t As String
    If IsNull(s) Then NormalizeText = "": Exit Function
    t = Trim$(CStr(s))
    On Error Resume Next
    t = StrConv(t, vbNarrow)
    On Error GoTo 0
    NormalizeText = t
End Function

Private Function NormalizeHeader(ByVal s As String) As String
    If Len(s) = 0 Then NormalizeHeader = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "") ' BOMé™¤å»
    NormalizeHeader = Trim$(s)
End Function

'=============================================================
' é…åˆ—ã‚­ãƒ£ãƒƒã‚·ãƒ¥
'=============================================================
Private Function GetTableArr(tbl As String) As Variant
    If m_tblCache Is Nothing Then Set m_tblCache = CreateObject("Scripting.Dictionary")
    If Not m_tblCache.Exists(tbl) Then
        m_tblCache(tbl) = TableData(tbl)
    End If
    GetTableArr = m_tblCache(tbl)
End Function

'=============================================================
' åˆ—å/åˆ—ç•ªå·ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
'=============================================================
Private Function Norm(ByVal s As String) As String
    If Len(s) = 0 Then Norm = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "")
    Norm = Trim$(s)
End Function

Public Function FindColumnIndex(arr As Variant, ColName As String) As Long
    Dim c As Long, target As String
    target = Norm(ColName)
    For c = 1 To UBound(arr, 2)
        If Norm(CStr(arr(1, c))) = target Then FindColumnIndex = c: Exit Function
    Next
    FindColumnIndex = 0
End Function

Public Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then IndexOfTable = i: Exit Function
    Next
    IndexOfTable = -1
End Function

Private Function SafeGetSrcColName(i As Long, tIdx As Long) As String
    Dim lb1 As Long, ub1 As Long, lb2 As Long, ub2 As Long
    On Error GoTo FAIL
    lb1 = LBound(Map_SrcCols, 1): ub1 = UBound(Map_SrcCols, 1)
    lb2 = LBound(Map_SrcCols, 2): ub2 = UBound(Map_SrcCols, 2)
    Dim tAdj As Long
    If lb2 = 1 And LBound(Map_TblNames) = 0 Then tAdj = tIdx + 1 Else tAdj = tIdx
    If i < lb1 Or i > ub1 Then GoTo FAIL
    If tAdj < lb2 Or tAdj > ub2 Then GoTo FAIL
    Dim v As Variant: v = Map_SrcCols(i, tAdj)
    If IsError(v) Or IsNull(v) Then GoTo FAIL
    If IsArray(v) Then GoTo FAIL
    SafeGetSrcColName = Trim$(CStr(v))
    Exit Function
FAIL:
    SafeGetSrcColName = ""
End Function

Private Function SafeGetSrcColNames(i As Long, tIdx As Long) As Collection
    Dim col As New Collection, raw As String, s As String
    raw = SafeGetSrcColName(i, tIdx)
    If Len(raw) = 0 Then Set SafeGetSrcColNames = col: Exit Function
    s = Replace$(raw, vbCrLf, vbLf)
    s = Replace$(s, vbCr, vbLf)
    s = Replace$(s, "|", vbLf)
    Dim arr() As String, k As Long, one As String
    arr = Split(s, vbLf)
    For k = LBound(arr) To UBound(arr)
        one = NormalizeHeader(arr(k))
        If Len(one) > 0 Then col.Add one
    Next
    Set SafeGetSrcColNames = col
End Function

Public Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long, names As Collection
    tIdx = IndexOfTable(Map_TblNames, baseTbl)
    If tIdx < LBound(Map_TblNames) Then CollectKeyColIndexesForBase = Array(): Exit Function
    kc = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then If names.Count > 0 Then kc = kc + 1
        End If
    Next
    If kc = 0 Then CollectKeyColIndexesForBase = Array(): Exit Function

    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc): cur = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Dim picked As Long: picked = 0
            Dim j As Long, nm As String, ci As Long
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then
                For j = 1 To names.Count
                    nm = names(j)
                    If IsNumeric(nm) Then ci = CLng(nm) Else ci = FindColumnIndex(baseArr, nm)
                    If ci > 0 Then picked = ci: Exit For
                Next
                If picked > 0 Then cur = cur + 1: idx(cur) = picked
            End If
        End If
    Next
    CollectKeyColIndexesForBase = idx
End Function

'=============================================================
' å®Ÿè¡Œæ™‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåˆ—ç•ªå·ï¼†joinåˆ¤å®šï¼‰æ§‹ç¯‰
'=============================================================
Public Sub BuildRuntimeCache(baseTbl As String)
    Dim outColsCnt As Long: outColsCnt = UBound(Map_OutCols) - LBound(Map_OutCols) + 1
    Cache_BaseTbl = baseTbl
    Cache_TblCount = UBound(Map_TblNames) - LBound(Map_TblNames) + 1
    ReDim Cache_ColIdx(1 To outColsCnt, LBound(Map_TblNames) To UBound(Map_TblNames))
    ReDim Cache_DoJoin(1 To outColsCnt)

    ' åˆ—ã”ã¨ã® join åˆ¤å®šï¼šCONCAT ã®ã¿ Trueã€ã‚­ãƒ¼åˆ—ã¯å¿…ãš False
    Dim c As Long
    For c = 1 To outColsCnt
        Cache_DoJoin(c) = (UCase$(Map_Mode(c)) = "CONCAT")
        If Map_IsKey(c) Then Cache_DoJoin(c) = False
    Next

    ' å„ãƒ†ãƒ¼ãƒ–ãƒ«ã®é…åˆ—ï¼ˆ1å›ã ã‘å–å¾—ï¼‰
    Dim t As Long, arr As Variant
    Dim tblArr() As Variant
    ReDim tblArr(LBound(Map_TblNames) To UBound(Map_TblNames))
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        tblArr(t) = GetTableArr(Map_TblNames(t))
    Next

    ' (åˆ—Ã—ãƒ†ãƒ¼ãƒ–ãƒ«) ã§å‚ç…§ã™ã‚‹åˆ—ç•ªå·ã®é…åˆ—ã‚’äº‹å‰ã«ç¢ºå®š
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        For c = 1 To outColsCnt
            Dim names As Collection: Set names = SafeGetSrcColNames(c, t)
            If Not names Is Nothing And names.Count > 0 Then
                Dim idxs() As Long, k As Long, nm As String, ci As Long, picked As Long
                arr = tblArr(t)
                ReDim idxs(1 To names.Count): picked = 0
                For k = 1 To names.Count
                    nm = names(k)
                    If IsNumeric(nm) Then ci = CLng(nm) Else ci = FindColumnIndex(arr, nm)
                    If ci > 0 Then picked = picked + 1: idxs(picked) = ci
                Next
                If picked > 0 Then
                    ReDim Preserve idxs(1 To picked)
                    Cache_ColIdx(c, t) = idxs
                Else
                    Cache_ColIdx(c, t) = Empty
                End If
            Else
                Cache_ColIdx(c, t) = Empty
            End If
        Next
    Next

    Cache_Built = True
End Sub

'=============================================================
' 1å¯¾å¤šæ™‚ã®æœ€å¤§å¢—å¹…
'=============================================================
Private Function MaxMatchesForKey(ByVal keyStr As String, baseTbl As String) As Long
    Dim t As Long, m As Long: m = 0
    If (Not Not Map_TblNames) = 0 Then MaxMatchesForKey = 1: Exit Function
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        Dim nm As String: nm = Map_TblNames(t)
        If nm = baseTbl Then
            If m < 1 Then m = 1
        Else
            Dim kd As Object: Set kd = KeyIndexMulti(nm)
            If Not kd Is Nothing Then
                If kd.Exists(keyStr) Then
                    If kd(keyStr).Count > m Then m = kd(keyStr).Count
                End If
            End If
        End If
    Next
    If m < 1 Then m = 1
    MaxMatchesForKey = m
End Function

'=============================================================
' é«˜é€Ÿç‰ˆï¼šVALUE/CONCAT rawå–å¾—ï¼ˆåˆ—ç•ªå·ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨ï¼‰
'=============================================================
Public Function BuildValueModeRaw_Fast(colIndex As Long, baseTbl As String, baseRow As Long, myKey As String, _
                                       Optional matchIndex As Long = 1) As String
    Dim t As Long, arr As Variant, idxs As Variant, acc As String, v As String
    Dim doJoin As Boolean: doJoin = Cache_DoJoin(colIndex)

    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        idxs = Cache_ColIdx(colIndex, t)
        If IsEmpty(idxs) Then GoTo CONT_T

        If Map_TblNames(t) = baseTbl Then
            If m_currentBaseTbl = baseTbl Then
                arr = m_currentBaseArr
            Else
                arr = GetTableArr(baseTbl)
            End If
            Dim k As Long
            For k = LBound(idxs) To UBound(idxs)
                v = CStr(arr(baseRow, idxs(k)))
                If doJoin Then
                    If Len(v) > 0 Then
                        If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
                    End If
                Else
                    If Len(v) > 0 Then BuildValueModeRaw_Fast = v: Exit Function
                End If
            Next
        Else
            Dim k2 As Long
            For k2 = LBound(idxs) To UBound(idxs)
                ' ä»–ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚­ãƒ¼ã§å¼•ã„ã¦ kç•ªç›®ã®ä¸€è‡´
                v = GetValueFromTableMulti(Map_TblNames(t), CStr(idxs(k2)), myKey, matchIndex)
                If doJoin Then
                    If Len(v) > 0 Then
                        If Len(acc) = 0 Then acc = v Else acc = acc & vbLf & v
                    End If
                Else
                    If Len(v) > 0 Then BuildValueModeRaw_Fast = v: Exit Function
                End If
            Next
        End If
CONT_T:
    Next
    BuildValueModeRaw_Fast = acc
End Function

'=============================================================
' JOIN æ¸ˆã¿ç„¡åŠ å·¥é…åˆ—ã®æ§‹ç¯‰ï¼ˆListã¯1å¯¾å¤šå¢—å¹…ï¼‰
'=============================================================
Public Function BuildJoinedRaw(baseTbl As String) As Variant
    Dim outColsCnt As Long: outColsCnt = UBound(Map_OutCols) - LBound(Map_OutCols) + 1

    If Len(baseTbl) = 0 Then
        Dim emptyArr() As Variant: ReDim emptyArr(1 To 1, 1 To outColsCnt)
        BuildJoinedRaw = emptyArr: Exit Function
    End If

    ' ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ§‹ç¯‰
    If Not Cache_Built Or Cache_BaseTbl <> baseTbl Then BuildRuntimeCache baseTbl

    ' ãƒ™ãƒ¼ã‚¹é…åˆ—ã‚’ä¸€åº¦ã ã‘æ´ã‚€
    Dim baseArr As Variant
    baseArr = GetTableArr(baseTbl)
    m_currentBaseTbl = baseTbl
    m_currentBaseArr = baseArr

    Dim baseKeyCols() As Long
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, baseTbl)

    ' è¡Œæ•°è¦‹ç©
    Dim totalRows As Long, r As Long, expand As Long, myKey As String
    totalRows = 0
    For r = 2 To UBound(baseArr, 1)
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        expand = 1
        If AllowOneToMany Then
            expand = MaxMatchesForKey(myKey, baseTbl)
            If expand < 1 Then expand = 1
        End If
        totalRows = totalRows + expand
    Next
    If totalRows = 0 Then
        Dim empty2() As Variant: ReDim empty2(1 To 1, 1 To outColsCnt)
        BuildJoinedRaw = empty2: Exit Function
    End If

    ' å‡ºåŠ›é…åˆ—
    Dim result() As Variant
    ReDim result(1 To totalRows, 1 To outColsCnt)
    ReDim m_baseRowIdx(1 To totalRows)

    ' å®Ÿãƒ‡ãƒ¼ã‚¿åŸ‹ã‚ï¼ˆé«˜é€Ÿç‰ˆï¼‰
    Dim outRow As Long, c As Long, k As Long
    outRow = 0
    For r = 2 To UBound(baseArr, 1)
        myKey = BuildKeyFromRow(baseArr, r, baseKeyCols)
        expand = 1
        If AllowOneToMany Then
            expand = MaxMatchesForKey(myKey, baseTbl)
            If expand < 1 Then expand = 1
        End If

        For k = 1 To expand
            outRow = outRow + 1
            m_baseRowIdx(outRow) = r
            For c = 1 To outColsCnt
                result(outRow, c) = BuildValueModeRaw_Fast(c, baseTbl, r, myKey, k)
            Next c
        Next k

        ' å¿œç­”ãªã—å›é¿ï¼ˆä½“æ„Ÿãƒ•ãƒªãƒ¼ã‚ºå¯¾ç­–ï¼‰
        If (outRow Mod 100) = 0 Then DoEvents
    Next r

    BuildJoinedRaw = result
End Function

'=============================================================
' ä»–ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰ kç•ªç›®ä¸€è‡´ã‚’å–å¾—
'=============================================================
Public Function GetValueFromTableMulti(tbl As String, col As String, keyStr As String, matchIndex As Long) As String
    On Error GoTo SAFE
    Dim kd As Object: Set kd = KeyIndexMulti(tbl)
    If kd Is Nothing Then Exit Function
    If Not kd.Exists(keyStr) Then Exit Function

    Dim arr As Variant: arr = GetTableArr(tbl)
    Dim ci As Long
    If IsNumeric(col) Then ci = CLng(col) Else ci = FindColumnIndex(arr, col)
    If ci = 0 Then Exit Function

    If kd(keyStr).Count >= matchIndex Then
        GetValueFromTableMulti = CStr(arr(kd(keyStr)(matchIndex), ci))
    End If
    Exit Function
SAFE:
    GetValueFromTableMulti = ""
End Function

'=============================================================
' ãƒ†ãƒ³ãƒ—ãƒ¬ç½®æ›ï¼ˆæ–‡å­—åˆ—ï¼‰
'=============================================================
Public Function ApplyTemplate(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                              ByVal processed As Boolean, Optional outColIndex As Long = -1) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        If processed Then
            valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        Else
            valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ApplyTemplate = Replace(s, """", "")
End Function

'=============================================================
' ãƒˆãƒ¼ã‚¯ãƒ³è§£æ±ºï¼ˆraw / processedï¼‰
'=============================================================
Private Function ResolveTokenRawWithIndex(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                          ByVal matchIndex As Long) As String
    Dim t As String, c As String, p As Long
    token = Replace(Replace(token, "{", ""), "}", "")
    p = InStr(token, ".")
    If p = 0 Then Exit Function
    t = Left$(token, p - 1): c = Mid$(token, p + 1)
    If t = baseTbl Then
        Dim arr As Variant, ci As Long
        If m_currentBaseTbl = baseTbl Then
            arr = m_currentBaseArr
        Else
            arr = GetTableArr(t)
        End If
        If IsNumeric(c) Then ci = CLng(c) Else ci = FindColumnIndex(arr, c)
        If ci > 0 Then ResolveTokenRawWithIndex = CStr(arr(baseRow, ci))
    Else
        ResolveTokenRawWithIndex = GetValueFromTableMulti(t, c, myKey, matchIndex)
    End If
End Function

Public Function ResolveTokenRaw(token As String, baseTbl As String, baseRow As Long, myKey As String) As String
    ResolveTokenRaw = ResolveTokenRawWithIndex(token, baseTbl, baseRow, myKey, 1)
End Function

Public Function ResolveTokenProcessed(token As String, baseTbl As String, baseRow As Long, myKey As String, _
                                      Optional outColIndex As Long = -1) As String
    Dim raw As Variant
    raw = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
    If outColIndex <= 0 Then
        ResolveTokenProcessed = CStr(raw)
    Else
        ResolveTokenProcessed = ApplyOneValueTransform(raw, Map_DataType(outColIndex))
    End If
End Function

'=============================================================
' IF æ§‹æ–‡ç¾¤
'=============================================================
Private Function HasIFSyntax(ByVal s As String) As Boolean
    s = UCase$(s)
    HasIFSyntax = (Left$(s, 3) = "IF(") Or (Left$(s, 6) = "IFALL(") Or (Left$(s, 6) = "IFANY(")
End Function

Private Function EvalIFLine(ByVal line As String, baseTbl As String, baseRow As Long, myKey As String, _
                            ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim pOpen As Long, pClose As Long, fn As String, inside As String
    pOpen = InStr(line, "("): pClose = InStrRev(line, ")")
    If pOpen = 0 Or pClose = 0 Or pClose <= pOpen Then Exit Function
    fn = UCase$(Left$(line, pOpen - 1))
    inside = Mid$(line, pOpen + 1, pClose - pOpen - 1)

    Dim args As Collection: Set args = SplitArgs(inside)
    If args.Count < 3 Then Exit Function

    Dim thenText As String, elseText As String
    thenText = StripQuotes(args(args.Count - 1))
    elseText  = StripQuotes(args(args.Count))

    Dim ok As Boolean
    Select Case fn
        Case "IF":    ok = EvalOneCondition(args(1), baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFALL": ok = EvalAllConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case "IFANY": ok = EvalAnyConditions(args, 1, args.Count - 2, baseTbl, baseRow, myKey, processed, outColIndex)
        Case Else:    ok = False
    End Select

    If ok Then
        EvalIFLine = ApplyTemplate(thenText, baseTbl, baseRow, myKey, processed, outColIndex)
    Else
        EvalIFLine = ApplyTemplate(elseText,  baseTbl, baseRow, myKey, processed, outColIndex)
    End If
End Function

Private Function EvalAllConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If Not EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAllConditions = False: Exit Function
        End If
    Next
    EvalAllConditions = True
End Function

Private Function EvalAnyConditions(args As Collection, idxFrom As Long, idxTo As Long, _
                                   baseTbl As String, baseRow As Long, myKey As String, _
                                   ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim i As Long
    For i = idxFrom To idxTo
        If EvalOneCondition(args(i), baseTbl, baseRow, myKey, processed, outColIndex) Then
            EvalAnyConditions = True: Exit Function
        End If
    Next
    EvalAnyConditions = False
End Function

Private Function EvalOneCondition(cond As String, baseTbl As String, baseRow As Long, myKey As String, _
                                  ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim p As Long, leftExpr As String, rightExpr As String
    Dim actual As String, expected As String, u As String
    cond = Trim$(cond): u = UCase$(cond)

    ' LIKE({..},"A*")
    If Left$(u, 5) = "LIKE(" And Right$(u, 1) = ")" Then
        Dim inside As String, a As Collection
        inside = Mid$(cond, 6, Len(cond) - 6)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            actual = GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(a(2))
            EvalOneCondition = (actual Like expected)
            Exit Function
        End If
    End If

    ' STARTSWITH/ENDSWITH/CONTAINS
    If Left$(u, 11) = "STARTSWITH" Or Left$(u, 9) = "ENDSWITH" Or Left$(u, 8) = "CONTAINS" Then
        Dim fn As String, ins As String, a2 As Collection
        fn = Left$(cond, InStr(cond, "(") - 1)
        ins = Mid$(cond, InStr(cond, "(") + 1, Len(cond) - InStr(cond, "(") - 1)
        Set a2 = SplitArgs(ins)
        If a2.Count = 2 Then
            actual = GetScalarValue(a2(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(a2(2))
            Select Case UCase$(fn)
                Case "STARTSWITH": EvalOneCondition = (Left$(actual, Len(expected)) = expected)
                Case "ENDSWITH":   EvalOneCondition = (Right$(actual, Len(expected)) = expected)
                Case "CONTAINS":   EvalOneCondition = (InStr(1, actual, expected, vbTextCompare) > 0)
            End Select
            Exit Function
        End If
    End If

    ' A = B
    p = InStr(cond, "=")
    If p = 0 Then EvalOneCondition = False: Exit Function
    leftExpr = Trim$(Left$(cond, p - 1))
    rightExpr = Trim$(Mid$(cond, p + 1))
    actual = GetScalarValue(leftExpr, baseTbl, baseRow, myKey, processed, outColIndex)
    expected = NormalizeText(StripQuotes(rightExpr))
    EvalOneCondition = (actual = expected)
End Function

'=============================================================
' GetScalarValueï¼ˆLEFT/RIGHT/MID/LEN + {tbl.col}ï¼‰
'=============================================================
Private Function GetScalarValue(expr As String, baseTbl As String, baseRow As Long, myKey As String, _
                                ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim u As String: u = UCase$(Trim$(expr))
    Dim inside As String, a As Collection
    If Left$(u, 5) = "LEFT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 6, Len(expr) - 6)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s As String, n As Long
            s = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n = CLng(Val(a(2)))
            GetScalarValue = Left$(s, n): Exit Function
        End If
    ElseIf Left$(u, 6) = "RIGHT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 7, Len(expr) - 7)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s2 As String, n2 As Long
            s2 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n2 = CLng(Val(a(2)))
            GetScalarValue = Right$(s2, n2): Exit Function
        End If
    ElseIf Left$(u, 4) = "MID(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Set a = SplitArgs(inside)
        If a.Count = 3 Then
            Dim s3 As String, st As Long, ln As Long
            s3 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            st = CLng(Val(a(2))): ln = CLng(Val(a(3)))
            GetScalarValue = Mid$(s3, st, ln): Exit Function
        End If
    ElseIf Left$(u, 4) = "LEN(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Dim s4 As String: s4 = NormalizeText(GetScalarValue(inside, baseTbl, baseRow, myKey, processed, outColIndex))
        GetScalarValue = CStr(Len(s4)): Exit Function
    End If

    Dim raw As String
    If processed Then raw = ResolveTokenProcessed(expr, baseTbl, baseRow, myKey, outColIndex) _
                    Else raw = ResolveTokenRaw(expr, baseTbl, baseRow, myKey)
    GetScalarValue = NormalizeText(raw)
End Function

'=============================================================
' æ–‡å­—åˆ—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
'=============================================================
Private Function StripQuotes(ByVal s As String) As String
    s = Trim$(s)
    If (Left$(s, 1) = "'" And Right$(s, 1) = "'") Or (Left$(s, 1) = """" And Right$(s, 1) = """") Then
        StripQuotes = Mid$(s, 2, Len(s) - 2)
    Else
        StripQuotes = s
    End If
End Function

Private Function SplitArgs(ByVal s As String) As Collection
    Dim col As New Collection
    Dim i As Long, ch As String * 1, inQ As Boolean, qChar As String * 1, buf As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch = """" Or ch = "'" Then
            If inQ Then
                If ch = qChar Then inQ = False
            Else
                inQ = True: qChar = ch
            End If
            buf = buf & ch
        ElseIf ch = "," And Not inQ Then
            col.Add Trim$(buf): buf = ""
        Else
            buf = buf & ch
        End If
    Next
    If Len(buf) > 0 Or s = "" Then col.Add Trim$(buf)
    Set SplitArgs = col
End Function

Public Function SplitDefToParts(ByVal def As String) As Collection
    Dim col As New Collection, tmp As String
    tmp = Replace$(def, vbCr, "")
    tmp = Replace$(tmp, "|", vbLf)
    Dim arr() As String, i As Long
    arr = Split(tmp, vbLf)
    For i = LBound(arr) To UBound(arr)
        If Trim$(arr(i)) <> "" Then col.Add Trim$(arr(i))
    Next
    Set SplitDefToParts = col
End Function

Public Function SplitExprToLines(ByVal def As String) As Collection
    Set SplitExprToLines = SplitDefToParts(def)
End Function

'=============================================================
' EXPRï¼šSUM(â€¦)
'=============================================================
Private Function EvalSUM(ByVal line As String, baseTbl As String, baseRow As Long, myKey As String, _
                         ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim inside As String, args As Collection, i As Long, v As String, total As Double
    inside = Mid$(line, 5, Len(line) - 5)
    Set args = SplitArgs(inside)
    For i = 1 To args.Count
        v = GetScalarValue(args(i), baseTbl, baseRow, myKey, processed, outColIndex)
        total = total + NumVal(v)
    Next
    EvalSUM = CStr(total)
End Function

'=============================================================
' EXPR è©•ä¾¡ï¼ˆIF/ãƒ†ãƒ³ãƒ—ãƒ¬/å¼ï¼‰
'=============================================================
Public Function EvaluateExpr(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                             ByVal processed As Boolean, Optional outColIndex As Long = -1) As Variant
    Dim lines As Collection: Set lines = SplitExprToLines(def)
    Dim i As Long, one As String, res As String, acc As String

    For i = 1 To lines.Count
        one = Trim$(lines(i))
        If one = "" Then GoTo CONT

        If HasIFSyntax(one) Then
            res = EvalIFLine(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        ElseIf InStr(one, """") > 0 Or InStr(one, "'") > 0 Then
            res = ApplyTemplate(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        Else
            Dim up As String: up = UCase$(one)
            If Left$(up, 4) = "SUM(" And Right$(up, 1) = ")" Then
                res = EvalSUM(one, baseTbl, baseRow, myKey, processed, outColIndex)
            Else
                Dim expr As String, v As Variant
                If processed Then expr = ReplaceTokensProcessedAsNumber(one, baseTbl, baseRow, myKey, outColIndex) _
                              Else expr = ReplaceTokensWithRaw(one, baseTbl, baseRow, myKey)
                ' Application.Evaluate ã‚’ã¾ãšè©¦ã™
                On Error Resume Next
                v = Application.Evaluate("=" & expr)
                On Error GoTo 0
                If IsError(v) Or VarType(v) = vbError Or IsEmpty(v) Then
                    res = CStr(SafeEval(expr))
                Else
                    res = CStr(v)
                End If
            End If
            If acc = "" Then acc = res Else acc = acc & vbLf & res
        End If
CONT:
    Next

    If processed And outColIndex > 0 Then
        EvaluateExpr = FinalizeByType(acc, Map_DataType(outColIndex))
    Else
        EvaluateExpr = acc
    End If
End Function

'=============================================================
' æ•°å¼ãƒˆãƒ¼ã‚¯ãƒ³ç½®æ›ï¼ˆéæ•°å€¤â†’0ï¼‰
'=============================================================
Public Function ReplaceTokensWithRaw(def As String, baseTbl As String, baseRow As Long, myKey As String) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        valStr = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        valStr = ToNumberOrZero(valStr)
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensWithRaw = s
End Function

Public Function ReplaceTokensProcessedAsNumber(def As String, baseTbl As String, baseRow As Long, myKey As String, outColIndex As Long) As String
    Dim s As String: s = def
    Dim pos As Long, pos2 As Long, token As String, valStr As String
    pos = InStr(s, "{")
    Do While pos > 0
        pos2 = InStr(pos + 1, s, "}")
        If pos2 = 0 Then Exit Do
        token = Mid$(s, pos + 1, pos2 - pos - 1)
        valStr = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        valStr = ToNumberOrZero(valStr)
        s = Left$(s, pos - 1) & valStr & Mid$(s, pos2 + 1)
        pos = InStr(pos + Len(valStr), s, "{")
    Loop
    ReplaceTokensProcessedAsNumber = s
End Function

'=============================================================
' Evaluate ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šç°¡æ˜“å››å‰‡æ¼”ç®—
'=============================================================
Public Function SafeEval(ByVal expr As String) As Double
    On Error GoTo FAIL
    expr = Replace$(expr, " ", "")
    expr = Replace$(expr, vbCr, "")
    expr = Replace$(expr, vbLf, "")
    expr = Replace$(expr, vbTab, "")
    If Len(expr) = 0 Then SafeEval = 0: Exit Function

    Dim nums() As Double, ops() As String, nTop As Long, oTop As Long
    ReDim nums(1 To 1): ReDim ops(1 To 1)
    nTop = 0: oTop = 0

    Dim prevKind As Integer: prevKind = 0 ' 0:é–‹å§‹,1:æ•°å€¤/")",2:æ¼”ç®—å­/"("
    Dim i As Long, ch As String, num As String

    i = 1
    Do While i <= Len(expr)
        ch = Mid$(expr, i, 1)
        If ch Like "[0-9.]" Then
            num = ""
            Do While i <= Len(expr)
                ch = Mid$(expr, i, 1)
                If ch Like "[0-9.]" Then num = num & ch: i = i + 1 Else Exit Do
            Loop
            nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
            nums(nTop) = CDbl(Val(num))
            prevKind = 1
            GoTo NEXTITER

        ElseIf ch = "(" Then
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2

        ElseIf ch = ")" Then
            Do While oTop > 0
                If ops(oTop) = "(" Then oTop = oTop - 1: Exit Do
                ApplyOp nums, nTop, ops, oTop
            Loop
            prevKind = 1

        ElseIf ch = "+" Or ch = "-" Or ch = "*" Or ch = "/" Then
            If ch = "-" And (prevKind = 0 Or prevKind = 2) Then
                nTop = nTop + 1: ReDim Preserve nums(1 To nTop): nums(nTop) = 0
            Else
                Do While oTop > 0 And Precedence(ops(oTop)) >= Precedence(ch)
                    ApplyOp nums, nTop, ops, oTop
                Loop
            End If
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2
        End If
        i = i + 1
NEXTITER:
    Loop

    Do While oTop > 0
        ApplyOp nums, nTop, ops, oTop
    Loop
    If nTop > 0 Then SafeEval = nums(nTop) Else SafeEval = 0
    Exit Function
FAIL:
    SafeEval = 0
End Function

Private Function Precedence(op As String) As Long
    Select Case op
        Case "+", "-": Precedence = 1
        Case "*", "/": Precedence = 2
        Case Else:     Precedence = 0
    End Select
End Function

Private Sub ApplyOp(ByRef nums() As Double, ByRef nTop As Long, ByRef ops() As String, ByRef oTop As Long)
    If oTop <= 0 Or nTop < 2 Then Exit Sub
    Dim b As Double, a As Double, op As String, res As Double
    b = nums(nTop): nTop = nTop - 1
    a = nums(nTop)
    op = ops(oTop): oTop = oTop - 1
    Select Case op
        Case "+": res = a + b
        Case "-": res = a - b
        Case "*": res = a * b
        Case "/": If b = 0 Then res = 0 Else res = a / b
        Case Else: res = b
    End Select
    nums(nTop) = res
End Sub

'=============================================================
' EXPRæœ€çµ‚å‹ã®æ•´å½¢ï¼ˆNUMBERã¯æ”¹è¡Œåˆç®—ï¼‰
'=============================================================
Private Function FinalizeByType(ByVal s As String, ByVal dataType As String) As String
    Select Case UCase$(dataType)
        Case "NUMBER"
            If Len(s) = 0 Then
                FinalizeByType = ""
            Else
                Dim total As Double, arr() As String, i As Long, one As String
                s = Replace$(Replace$(s, vbCrLf, vbLf), vbCr, vbLf)
                arr = Split(s, vbLf)
                For i = LBound(arr) To UBound(arr)
                    one = Trim$(arr(i))
                    If Len(one) > 0 Then total = total + CDbl(Val(ToNumberOrZero(one)))
                Next
                FinalizeByType = CStr(CLng(total))
            End If
        Case "DATE"
            If Len(s) = 0 Then FinalizeByType = "" _
            ElseIf IsDate(s) Then FinalizeByType = Format$(CDate(s), "yyyy/mm/dd") _
            Else FinalizeByType = ""
        Case Else
            FinalizeByType = s
    End Select
End Function

'=============================================================
' å˜å€¤ã®å‹å¤‰æ›ã®ã¿
'=============================================================
Public Function ApplyOneValueTransform(v As Variant, dataType As String) As String
    Dim w As Variant: w = v
    Select Case UCase$(dataType)
        Case "NUMBER": If Len(CStr(w)) > 0 And IsNumeric(w) Then w = CLng(w) Else w = ""
        Case "DATE":   If Len(CStr(w)) > 0 And IsDate(w) Then w = Format$(CDate(w), "yyyy/mm/dd") Else w = ""
        Case Else:     w = CStr(w)
    End Select
    ApplyOneValueTransform = CStr(w)
End Function

'=============================================================
' å¤‰æ›æœ¬ä½“ï¼ˆEXPR ä»¥å¤–ã¯æœ€çŸ­ãƒ‘ã‚¹ï¼‰
'=============================================================
Public Function ApplyTransformSmart(src As Variant) As Variant
    Dim rows As Long, cols As Long
    rows = UBound(src, 1): cols = UBound(src, 2)
    Dim dst() As Variant: ReDim dst(1 To rows, 1 To cols)

    Dim r As Long, c As Long
    For r = 1 To rows
        For c = 1 To cols
            Select Case UCase$(Map_Mode(c))
                Case "EXPR"
                    dst(r, c) = EvaluateExpr(Map_Def(c), m_baseTblName, m_baseRowIdx(r), GetKeyForRow(r), True, c)
                Case "CONCAT"
                    ' æ–‡å­—é€£çµåˆ—ã¯ BuildValueModeRaw_Fast ã§æ”¹è¡Œé€£çµæ¸ˆã¿ â†’ å‹å¤‰æ›ã®ã¿
                    dst(r, c) = ApplyOneValueTransform(src(r, c), Map_DataType(c))
                Case Else
                    dst(r, c) = ApplyOneValueTransform(src(r, c), Map_DataType(c))
            End Select
        Next
        If (r Mod 200) = 0 Then DoEvents
    Next
    ApplyTransformSmart = dst
End Function

Private Function GetKeyForRow(r As Long) As String
    Dim baseArr As Variant, baseKeyCols() As Long
    If Len(m_baseTblName) = 0 Then Exit Function
    baseArr = GetTableArr(m_baseTblName)
    baseKeyCols = CollectKeyColIndexesForBase(baseArr, m_baseTblName)
    GetKeyForRow = BuildKeyFromRow(baseArr, m_baseRowIdx(r), baseKeyCols)
End Function


â¸»

é©ç”¨ãƒã‚¤ãƒ³ãƒˆï¼ˆé‡è¦ï¼‰
	â€¢	SEQ ãŒæ”¹è¡Œã«ãªã‚‹å•é¡Œï¼š
	â€¢	Cache_DoJoin(c) = (Map_Mode(c) = "CONCAT") + If Map_IsKey(c) Then False ã§ã€ã‚­ãƒ¼åˆ—ã¯å¿…ãšå˜å€¤ã€CONCAT åˆ—ã ã‘æ”¹è¡Œé€£çµã«ãªã‚Šã¾ã™ã€‚
	â€¢	BuildJoinedRaw ã¯ BuildValueModeRaw_Fast ã‚’ä½¿ç”¨ï¼ˆforceJoinMultiple ã¯ä¸è¦ï¼‰ã«ã—ã¦ã„ã¾ã™ã€‚
	â€¢	100ä»¶è¶…ã§å›ºã¾ã‚‹ï¼š
	â€¢	TableData ã®é…åˆ—ã‚’ GetTableArr ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦å†åˆ©ç”¨ï¼ˆãƒ™ãƒ¼ã‚¹/ä»–ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã‚‚ï¼‰ã€‚
	â€¢	åˆ—ç•ªå·ã‚’ BuildRuntimeCache ã§äº‹å‰ç¢ºå®šã—ã€ã‚»ãƒ«ã”ã¨ã«åˆ—åâ†’åˆ—ç•ªå·æ¤œç´¢ã‚’ã—ã¾ã›ã‚“ã€‚
	â€¢	100è¡Œ/200è¡Œã”ã¨ã« DoEvents ã‚’å…¥ã‚Œã¦â€œå¿œç­”ãªã—â€ã‚’å›é¿ã€‚
	â€¢	å‡¦ç†å…¥å£/å‡ºå£ã§ SpeedUpON/OFF ã‚’å¿…ãšå‘¼ã‚“ã§ãã ã•ã„ï¼ˆImport/Process/Export ã™ã¹ã¦ï¼‰ã€‚
	â€¢	åˆç®—ãŒ 0 ã«ãªã‚‹ï¼š
	â€¢	Definitions ã§ SUM(...) ãŒä½¿ãˆã¾ã™ã€‚
	â€¢	ãã‚Œä»¥å¤–ã®å››å‰‡æ¼”ç®—ã¯ Application.Evaluate("=" & expr) â†’ å¤±æ•—æ™‚ SafeEval ã®é †ã«è©•ä¾¡ã€‚
	â€¢	æ•°å€¤å‹ã®æœ€çµ‚æ•´å½¢ã¯ æ”¹è¡Œã”ã¨åˆç®—ï¼ˆFinalizeByTypeï¼‰ã«ã€‚

â¸»

å¿…è¦ãªã‚‰ã€ã“ã®ä¸Šã§ã€Œã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã® JOINï¼ˆä¾‹ï¼šJOIN(", ")ï¼‰ã€ã‚„ã€â‘¢ã®æ­£è¦åŒ–ï¼ˆâ€œA-1â€ ã«çµ±ä¸€ï¼‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–ã‚‚æ‹¡å¼µã§ãã¾ã™ã€‚ã¾ãšã¯ã“ã®ãƒ•ãƒ«ç‰ˆã§SEQã®å˜å€¤åŒ–ã¨ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®é€Ÿåº¦/å®‰å®šã‚’ã”ç¢ºèªãã ã•ã„ã€‚