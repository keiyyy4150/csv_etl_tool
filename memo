なるほど、式は正しいのに空になる――となると、実装側で「評価時の文字列整形」か「IFALLの結合評価」のどちらかで落ちています。
以下の最小パッチで“トリム＆半角化”を入れつつ、IFALL/LIKE/LEFT/RIGHT系の評価を堅くし、さらにログで“実際に何が比較されているか”を確認できるようにします。質問なしで貼替えだけで動く形にしています。

⸻

1) 文字列を安全に評価する共通関数を追加（Trim & 半角化）

modJoinAndEval（評価系があるモジュール）に追加してください。

' 文字列の正規化：Trim → 可能なら半角化（全角A/1対策）→ Null回避
Private Function NormalizeText(ByVal s As Variant) As String
    Dim t As String
    If IsNull(s) Then
        NormalizeText = ""
        Exit Function
    End If
    t = CStr(s)
    t = Trim$(t)
    On Error Resume Next
    ' 日本語CSVでありがちな全角英数字混在対策（環境依存だが害はない）
    t = StrConv(t, vbNarrow)
    On Error GoTo 0
    NormalizeText = t
End Function


⸻

2) GetScalarValue を正規化して返すよう修正

先にお渡しした GetScalarValue を、取得した値に NormalizeText を必ず通すように変更します。
（LEFT/RIGHT/MID/LEN の内部でも、対象文字列に NormalizeText を適用）

Private Function GetScalarValue(expr As String, baseTbl As String, baseRow As Long, myKey As String, _
                                ByVal processed As Boolean, ByVal outColIndex As Long) As String
    Dim u As String: u = UCase$(Trim$(expr))
    Dim inside As String, a As Collection

    If Left$(u, 5) = "LEFT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 6, Len(expr) - 6)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s As String, n As Long
            s = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n = CLng(Val(a(2)))
            GetScalarValue = Left$(s, n)
            Exit Function
        End If

    ElseIf Left$(u, 6) = "RIGHT(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 7, Len(expr) - 7)
        Set a = SplitArgs(inside)
        If a.Count = 2 Then
            Dim s2 As String, n2 As Long
            s2 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            n2 = CLng(Val(a(2)))
            GetScalarValue = Right$(s2, n2)
            Exit Function
        End If

    ElseIf Left$(u, 4) = "MID(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Set a = SplitArgs(inside)
        If a.Count = 3 Then
            Dim s3 As String, st As Long, ln As Long
            s3 = NormalizeText(GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex))
            st = CLng(Val(a(2)))
            ln = CLng(Val(a(3)))
            GetScalarValue = Mid$(s3, st, ln)
            Exit Function
        End If

    ElseIf Left$(u, 4) = "LEN(" And Right$(u, 1) = ")" Then
        inside = Mid$(expr, 5, Len(expr) - 5)
        Dim s4 As String
        s4 = NormalizeText(GetScalarValue(inside, baseTbl, baseRow, myKey, processed, outColIndex))
        GetScalarValue = CStr(Len(s4))
        Exit Function
    End If

    ' 最終的には {tbl.col} を解決 → 正規化
    Dim raw As String
    If processed Then
        raw = ResolveTokenProcessed(expr, baseTbl, baseRow, myKey, outColIndex)
    Else
        raw = ResolveTokenRaw(expr, baseTbl, baseRow, myKey)
    End If
    GetScalarValue = NormalizeText(raw)
End Function


⸻

3) EvalOneCondition を実際の左右値をログ出し＋LIKE/STARTSWITH/ENDSWITH/CONTAINSの評価を堅く

Private Function EvalOneCondition(cond As String, baseTbl As String, baseRow As Long, myKey As String, _
                                  ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim p As Long, leftExpr As String, rightExpr As String
    Dim actual As String, expected As String, u As String
    cond = Trim$(cond)
    u = UCase$(cond)

    ' LIKE({..},"A*") 形式
    If Left$(u, 5) = "LIKE(" And Right$(u, 1) = ")" Then
        Dim inside As String, args As Collection
        inside = Mid$(cond, 6, Len(cond) - 6)
        Set args = SplitArgs(inside)
        If args.Count = 2 Then
            actual = GetScalarValue(args(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(args(2))
            EvalOneCondition = (actual Like expected)
            WriteLog "DEBUG", "[COND LIKE] actual='" & actual & "' pattern='" & expected & "' -> " & EvalOneCondition
            Exit Function
        End If
    End If

    ' STARTSWITH/ENDSWITH/CONTAINS
    If Left$(u, 11) = "STARTSWITH" Or Left$(u, 9) = "ENDSWITH" Or Left$(u, 8) = "CONTAINS" Then
        Dim fn As String, ins As String, a As Collection
        fn = Left$(cond, InStr(cond, "(") - 1)
        ins = Mid$(cond, InStr(cond, "(") + 1, Len(cond) - InStr(cond, "(") - 1)
        Set a = SplitArgs(ins)
        If a.Count = 2 Then
            actual = GetScalarValue(a(1), baseTbl, baseRow, myKey, processed, outColIndex)
            expected = StripQuotes(a(2))
            Select Case UCase$(fn)
                Case "STARTSWITH": EvalOneCondition = (Left$(actual, Len(expected)) = expected)
                Case "ENDSWITH":   EvalOneCondition = (Right$(actual, Len(expected)) = expected)
                Case "CONTAINS":   EvalOneCondition = (InStr(1, actual, expected, vbTextCompare) > 0)
            End Select
            WriteLog "DEBUG", "[COND " & UCase$(fn) & "] actual='" & actual & "' expected='" & expected & "' -> " & EvalOneCondition
            Exit Function
        End If
    End If

    ' A = B 比較
    p = InStr(cond, "=")
    If p = 0 Then
        EvalOneCondition = False
        WriteLog "DEBUG", "[COND] no '=' in '" & cond & "'"
        Exit Function
    End If
    leftExpr = Trim$(Left$(cond, p - 1))
    rightExpr = Trim$(Mid$(cond, p + 1))
    actual = GetScalarValue(leftExpr, baseTbl, baseRow, myKey, processed, outColIndex)
    expected = NormalizeText(StripQuotes(rightExpr))

    EvalOneCondition = (actual = expected)
    WriteLog "DEBUG", "[COND =] actual='" & actual & "' expected='" & expected & "' -> " & EvalOneCondition
End Function


⸻

4) IFALL の評価を厳密＆空条件スキップに

IFALL の中で、カンマ区切りの各条件を EvalOneCondition に投げて評価します。
空文字の条件は無視、一つでも False があれば False。全て True で True。

Private Function EvalIFALL(argList As String, baseTbl As String, baseRow As Long, myKey As String, _
                           ByVal processed As Boolean, ByVal outColIndex As Long) As Boolean
    Dim conds As Collection, i As Long, c As String
    Set conds = SplitArgs(argList)
    If conds Is Nothing Or conds.Count = 0 Then
        EvalIFALL = False
        Exit Function
    End If

    EvalIFALL = True
    For i = 1 To conds.Count
        c = Trim$(conds(i))
        If Len(c) = 0 Then
            ' 空条件はスキップ
        Else
            If Not EvalOneCondition(c, baseTbl, baseRow, myKey, processed, outColIndex) Then
                EvalIFALL = False
                Exit For
            End If
        End If
    Next i
End Function

そして、IF(...) の実装側（EvalIFLine など）で IFALL( を見つけたらこの関数を呼ぶようにして下さい（既に実装がある場合は、上記仕様に合うよう差し替え／補強）。

⸻

5) これで期待できること
	•	取得した元値（{pcm_t_... . 総付景品2_2}）が "A-1" でも、末尾スペースや全角Ａ／１混入でも、NormalizeText により "A-1" として扱われます。
	•	LEFT(...,1)="A" と RIGHT(...,1)="1" の両方が Trueになれば、IFALL が True → "A-1" が出力されます。
	•	なお、実際に何が比較されているかはログに DEBUG で出ます：
	•	[COND =] actual='A' expected='A' -> True
	•	[COND RIGHT] ...（LIKE/STARTSWITH/ENDSWITHの場合も同様）

⸻

6) 念のための“式そのもの”の代替（エンジン依存をさらに避ける書き方）

上記パッチを入れてもなお通らない場合、Definitionsの式をLIKE/IFALLで書くのも手です（内部は同じ評価器を通します）：

IF(
  IFALL(
    LIKE({pcm_t_景表法遵法チェック結果_総付景品.総付景品2_2},"A*"),
    LIKE({pcm_t_景表法遵法チェック結果_総付景品.総付景品2_2},"*1")
  ),
  "A-1",
  ""
)

この書き方でも、上の評価器でちゃんと True になります。

⸻

7) それでも空になる場合の“よくある落とし穴”
	•	トークン名の完全一致：{テーブル.列} が Mappingのテーブル名（G列以降）・CSVファイル名・ヘッダと一致しているか。
→ どこか一箇所でも全角／半角、スペース、濁点の違いがあると解決できません。
→ ログに ResolveTokenRaw / Processed 側で DEBUG を足して、実際に引けているか見るのが早いです。
	•	評価タイミング：該当列が先に加工で空にされていて processed:=True のときに取っていないか。
→ 当該式を定義している「出力カラム」の**計算順（No列）**が早すぎないかチェック。
	•	型の比較：expected が "1" なのに actual が "１"（全角）や "1 "（スペース入り）
→ 今回の Normalize で吸収します。

⸻

まずは上記 1)〜4) のパッチを入れて、ログの DEBUG を一度確認してみてください。
actual='A' / actual='1' が見えて -> True になっていれば、最終結果 "A-1" が入るはずです。