# ================================
# CSVエンコード/改行修正 + 元CSVをZIP化（コピー保存版）
# ================================

# スクリプト自身が置かれているフォルダ
$folderPath = Split-Path -Parent $MyInvocation.MyCommand.Definition

# 対象CSV
$csvFiles = Get-ChildItem -LiteralPath $folderPath -Filter *.csv -File

if (-not $csvFiles) {
    Write-Host "CSVファイルが見つかりませんでした。フォルダ: $folderPath"
    return
}

# ZIPファイル名（タイムスタンプ付きで重複回避）
$zipPath = Join-Path $folderPath ("original_csv_backup_" + (Get-Date -Format "yyyyMMdd_HHmmss") + ".zip")

# 既存のZIPが同名であれば削除（通常は衝突しない想定）
if (Test-Path -LiteralPath $zipPath) {
    Remove-Item -LiteralPath $zipPath -Force
}

Write-Host "=== 元CSVをZIPに圧縮中... ==="
Compress-Archive -LiteralPath ($csvFiles.FullName) -DestinationPath $zipPath -Force
Write-Host "→ ZIP作成完了: $zipPath"
Write-Host ""

# UTF-8 BOM付きエンコーダ（New-Objectの括弧落ちなどを避けるため静的コンストラクタで作成）
$utf8Bom = [System.Text.UTF8Encoding]::new($true)

# 文字列（テキスト）に変換する関数（BOM/推定を含む）
function Get-TextFromBytes {
    param(
        [byte[]]$Bytes
    )

    # BOM判定（UTF-8 / UTF-16LE / UTF-16BE）
    if ($Bytes.Length -ge 3 -and $Bytes[0] -eq 0xEF -and $Bytes[1] -eq 0xBB -and $Bytes[2] -eq 0xBF) {
        return [System.Text.Encoding]::UTF8.GetString($Bytes, 3, $Bytes.Length - 3)
    }
    elseif ($Bytes.Length -ge 2 -and $Bytes[0] -eq 0xFF -and $Bytes[1] -eq 0xFE) {
        return [System.Text.Encoding]::Unicode.GetString($Bytes)
    }
    elseif ($Bytes.Length -ge 2 -and $Bytes[0] -eq 0xFE -and $Bytes[1] -eq 0xFF) {
        return [System.Text.Encoding]::BigEndianUnicode.GetString($Bytes)
    }
    else {
        # まずUTF-8で読んでみて、ダメそうならShift_JISにフォールバック
        try {
            $tmp = [System.Text.Encoding]::UTF8.GetString($Bytes)
            # 再エンコード往復で妥当性軽チェック
            $round = [System.Text.Encoding]::UTF8.GetBytes($tmp)
            if ($round.Length -ge 1) { return $tmp }
        } catch { }

        try {
            $sjis = [System.Text.Encoding]::GetEncoding("shift_jis")
            return $sjis.GetString($Bytes)
        } catch {
            # 最後の手段としてUTF-8で返す
            return [System.Text.Encoding]::UTF8.GetString($Bytes)
        }
    }
}

# 改行統一：混在をLFに正規化→CRLF化
function Normalize-Newlines {
    param([string]$Text)
    $t = $Text -replace "`r`n|`r|`n", "`n"
    return ($t -replace "`n", "`r`n")
}

Write-Host "=== CSV修正版（*_fixed.csv）を作成中... ==="
foreach ($file in $csvFiles) {
    Write-Host ("修正中: " + $file.Name)

    # バイナリ読込
    $bytes = [System.IO.File]::ReadAllBytes($file.FullName)

    # テキスト化（BOM/UTF-8/Shift_JIS推定）
    $text = Get-TextFromBytes -Bytes $bytes

    # 改行をCRLFへ統一
    $text = Normalize-Newlines -Text $text

    # 出力ファイル名（sample.csv -> sample_fixed.csv）
    $newFile = Join-Path $folderPath ($file.BaseName + "_fixed.csv")

    # UTF-8 BOM付きで保存（ここで括弧・カンマ・引用符の崩れがあるとエラーになるので注意）
    [System.IO.File]::WriteAllText($newFile, $text, $utf8Bom)

    Write-Host ("→ 修正版を作成: " + $newFile)
}

Write-Host ""
Write-Host "=== 全CSV処理完了！==="
Write-Host "元データはZIP化済み、修正版は *_fixed.csv として保存されています。"