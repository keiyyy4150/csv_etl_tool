やったね！範囲指定の修正で直ったの良かったです 👏
で、「クリア」ボタンの体感が重い件、ListObject のリサイズ／クリアのやり方を変えると一気に速くなります。ポイントは以下の3つだけ。

速くするコツ（要点）
	1.	ゼロ行に近いサイズへ一発リサイズ
　今の ResetMasterSize は既定（B4 が空なら 20,000 行）まで広げてから ClearContents しています。ここが重い。
　→ クリア時は ヘッダーのみ（= 0 行） へ縮めるのが最速です。DataBodyRange.ClearContents 自体を避けるのがキモ。
	2.	AutoFilter解除は“あるときだけ”
　ShowAllData はフィルタ未適用状態で呼ぶと内部的に重いです。
　→ If lo.AutoFilter.FilterMode Then lo.AutoFilter.ShowAllData
	3.	画面/計算/イベントOFFは既にOK
　この3つの OFF は効いています。追加で DisplayPageBreaks = False も地味に効きます（ページ分割線の再計算を防ぐ）。

⸻

差し替えコード（最小改修）

A. クリア専用の「超軽量リサイズ」を用意

'=== クリア専用：テーブルをヘッダーのみ（0行）に縮める ===
Private Sub ShrinkToHeaderOnly(lo As ListObject)
    If lo Is Nothing Then Exit Sub
    Dim ws As Worksheet: Set ws = lo.Parent
    Dim hdr As Range: Set hdr = lo.HeaderRowRange
    ' データ行を持たないサイズに一発リサイズ
    lo.Resize hdr
End Sub

B. ClearData を高速版に置き換え

Public Sub ClearData()
    Dim prevCalc As XlCalculation
    Dim prevUpd As Boolean, prevEvt As Boolean, prevDisp As Boolean
    Dim prevPB As Boolean
    Dim t0 As Double: t0 = Timer

    If Len(CurrentMasterTableName) = 0 Then UsePipelineMain

    ' 高速化
    On Error Resume Next
    prevUpd = Application.ScreenUpdating
    prevEvt = Application.EnableEvents
    prevDisp = Application.DisplayAlerts
    prevCalc = Application.Calculation
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    Application.Calculation = xlCalculationManual
    On Error GoTo 0

    On Error GoTo EH
    Dim lo As ListObject
    Set lo = GetListObjectByName(CurrentMasterTableName)
    If Not lo Is Nothing Then
        ' ページ分割線を抑止（効く）
        prevPB = lo.Parent.DisplayPageBreaks
        lo.Parent.DisplayPageBreaks = False

        ' フィルタ解除は「かかっている時だけ」
        On Error Resume Next
        If Not lo.AutoFilter Is Nothing Then
            If lo.AutoFilter.FilterMode Then lo.AutoFilter.ShowAllData
        End If
        On Error GoTo 0

        ' ★最重要：ヘッダーのみへ縮める（DataBodyRange.ClearContentsは使わない）
        ShrinkToHeaderOnly lo

        ' もし「初期行を確保しておきたい」運用なら、ここで軽く広げる（例：1行だけ）
        ' lo.Resize lo.HeaderRowRange.Resize(2, lo.HeaderRowRange.Columns.Count)
        lo.Parent.DisplayPageBreaks = prevPB
    End If

    ' 中間データの解放（既存のままでOK）
    HasRaw = False
    IsProcessed = False
    On Error Resume Next
    If (Not Not RawJoined) <> 0 Then Erase RawJoined
    If (Not Not m_baseRowIdx) <> 0 Then Erase m_baseRowIdx
    On Error GoTo 0
    m_baseTblName = ""
    Set TableData = Nothing
    Set KeyIndexSingle = Nothing
    Set KeyIndexMulti = Nothing

DONE:
    ' 戻す
    On Error Resume Next
    Application.ScreenUpdating = prevUpd
    Application.EnableEvents = prevEvt
    Application.DisplayAlerts = prevDisp
    Application.Calculation = prevCalc
    On Error GoTo 0

    MsgBox "初期化しました。（" & Format(Timer - t0, "0.00") & "s）", vbInformation
    Exit Sub

EH:
    On Error Resume Next
    Application.ScreenUpdating = prevUpd
    Application.EnableEvents = prevEvt
    Application.DisplayAlerts = prevDisp
    Application.Calculation = prevCalc
    On Error GoTo 0
    MsgBox "ClearDataでエラー: " & Err.Description, vbCritical
End Sub

これで「大量行にリサイズ→ClearContents」の重い手順を完全に回避できます。
体感は桁違いに軽くなるはず。

⸻

補足（運用面の選択肢）
	•	「B4 の既定行数」運用は Import 時だけに使う
クリア時は 0 行、Import/Paste 時に必要なだけ一発で広げる（PasteToMasterByTable で Resize 済みなら不要）。
	•	テーブルの書式劣化対策
ヘッダーのみリサイズは書式を壊しませんが、スタイルが重い場合は
lo.TableStyle = "TableStyleLight1" 等の軽量スタイルへ変更も効果的。
	•	巨大ワークシート対策
クリア後に ws.UsedRange を軽く触る（Dim dummy:Set dummy = ws.UsedRange）と“幽霊UsedRange”を縮められて保存サイズが下がることがあります。

⸻

必要なら、既存の ResetMasterSize を「Import/貼り付け専用」にして、ClearData では呼ばない構成に切り分けるパッチも用意できます。試してみて、まだ重い箇所があれば計測ログ（処理段階ごとの Timer）仕込みもご提案します。