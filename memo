OK！いまの BuildDefinitionFromSheet を“引数つき定義ID”に対応させる最小改修を、貼り替えだけでいける形で出します。
ポイントは2つだけです。
	1.	Mappingの定義IDセルに DefName|arg1|arg2|... と書けるようにする
	2.	Definitionsのロジックは {#1}, {#2}… のプレースホルダを使う
	•	展開は 評価直前に実施（後方互換OK）

⸻

貼り替えコード（このモジュール内に追記・差し替え）

1) まず、プレースホルダ展開＆定義IDパースの小さなヘルパーを追加

'=== 追加：定義IDセルを「定義名」と「引数配列」に分解 ===
' 形式: DefName|arg1|arg2|...
Private Sub ParseDefId(ByVal defIdRaw As String, ByRef defName As String, ByRef defArgs() As String)
    Dim parts() As String, i As Long
    defIdRaw = Trim$(defIdRaw)
    parts = Split(defIdRaw, "|")

    If UBound(parts) >= 0 Then
        defName = Trim$(parts(0))
    Else
        defName = ""
    End If

    If UBound(parts) >= 1 Then
        ReDim defArgs(1 To UBound(parts))
        For i = 1 To UBound(parts)
            defArgs(i) = Trim$(parts(i))
        Next
    Else
        Erase defArgs
    End If
End Sub

'=== 追加：Definitionsロジック内の {#i} を引数で置換 ===
Private Function ExpandDefLogic(ByVal logicTemplate As String, ByRef defArgs() As String) As String
    Dim i As Long, s As String
    s = logicTemplate
    If Not (Not defArgs) = 0 Then
        For i = LBound(defArgs) To UBound(defArgs)
            s = Replace$(s, "{#" & CStr(i) & "}", defArgs(i))
        Next
    End If
    ExpandDefLogic = s
End Function

2) つぎに、元の BuildDefinitionFromSheet を“テンプレ取得→展開”に対応させます
	•	既存本体は テンプレ取得関数に切り出し（中身はほぼそのまま）
	•	外側の BuildDefinitionFromSheet は 引数つきIDを受け取り、展開して返す

'=========================================================
' 外側：引数つきの定義IDを受け取り、テンプレを展開して返す
'=========================================================
Public Function BuildDefinitionFromSheet(defIdRaw As String, Optional definitionsListName As String = "Definitions") As String
    Dim defName As String, defArgs() As String
    Dim tmpl As String

    ' 1) "DefName|arg1|arg2|..." を分解
    ParseDefId defIdRaw, defName, defArgs
    If Len(defName) = 0 Then
        BuildDefinitionFromSheet = ""
        Exit Function
    End If

    ' 2) Definitionsから defName のロジック（テンプレ）を取得
    tmpl = BuildDefinitionTemplateFromSheet(defName, definitionsListName)

    ' 3) {#i} を引数で展開して返す（引数が無ければそのまま）
    BuildDefinitionFromSheet = ExpandDefLogic(tmpl, defArgs)
End Function

'=========================================================
' 内側：Definitionsから「定義名」に一致するロジック群を連結して返す（テンプレ）
'   ※元の BuildDefinitionFromSheet の本体をほぼそのまま移植
'=========================================================
Private Function BuildDefinitionTemplateFromSheet(defName As String, Optional definitionsListName As String = "Definitions") As String
    Dim lo As ListObject
    Set lo = GetListObjectByNameEx(definitionsListName)
    If lo Is Nothing Then Err.Raise vbObjectError + 3401, , "Definitionsテーブル(" & definitionsListName & ")が見つかりません。"
    If lo.DataBodyRange Is Nothing Then BuildDefinitionTemplateFromSheet = "": Exit Function

    ' ヘッダー列位置
    Dim cId As Long, cVer As Long, cLine As Long, cLogic As Long
    cId = FindHeaderIndexEx(lo, "定義ID")
    cVer = FindHeaderIndexEx(lo, "バージョン")    ' 任意
    cLine = FindHeaderIndexEx(lo, "行No")
    cLogic = FindHeaderIndexEx(lo, "ロジック")
    If cId = 0 Or cLine = 0 Or cLogic = 0 Then
        Err.Raise vbObjectError + 3402, , "Definitionsの見出しは『定義ID／行No／ロジック（＋任意でバージョン）』が必要です。"
    End If

    ' 最大バージョン
    Dim maxVer As Long
    maxVer = MaxVersionForIdEx(lo, cId, cVer, defName)

    ' 行No→ロジック の一時格納
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")

    Dim r As Range, idv As String, vv As Variant, lineNo As Long, logicText As String
    For Each r In lo.DataBodyRange.Rows
        idv = CStr(r.Cells(1, cId).Value)
        If StrComp(idv, defName, vbTextCompare) = 0 Then
            If cVer > 0 Then
                vv = r.Cells(1, cVer).Value
                If IsNumeric(vv) Then
                    If CLng(vv) <> maxVer Then GoTo CONT_ROW
                Else
                    GoTo CONT_ROW
                End If
            End If

            vv = r.Cells(1, cLine).Value
            If Not IsNumeric(vv) Then GoTo CONT_ROW
            lineNo = CLng(vv)

            logicText = CStr(r.Cells(1, cLogic).Value)
            If Len(Trim$(logicText)) = 0 Then GoTo CONT_ROW

            dict(lineNo) = logicText   ' 同じ行No重複は後勝ち
        End If
CONT_ROW:
    Next

    If dict.Count = 0 Then BuildDefinitionTemplateFromSheet = "": Exit Function

    ' 昇順でJoin
    Dim keys() As Variant, i As Long, j As Long, tmp As Variant, acc As String
    keys = dict.Keys
    For i = LBound(keys) To UBound(keys) - 1
        For j = i + 1 To UBound(keys)
            If CLng(keys(i)) > CLng(keys(j)) Then
                tmp = keys(i): keys(i) = keys(j): keys(j) = tmp
            End If
        Next
    Next

    acc = ""
    For i = LBound(keys) To UBound(keys)
        If Len(acc) = 0 Then
            acc = dict(keys(i))
        Else
            acc = acc & vbLf & dict(keys(i))
        End If
    Next

    BuildDefinitionTemplateFromSheet = acc
End Function

これで、呼び出し側は今までどおり BuildDefinitionFromSheet(Map_Def(i)) を呼ぶだけでOK。
Map_Def(i) に DefName|... と書いてあれば {#i} が展開され、引数が無ければ従来どおりそのまま返る“後方互換”です。

⸻

使い方の例

Mapping 側（定義IDセルの記載）

A1_PREFIX_SUFFIX|{pcm_t_コンプラ相談.相談者部署CD}|"A"|"1"

	•	第1引数：列トークン（クォート不要）
	•	第2・第3引数：文字リテラル（クォート推奨）

Definitions 側（テンプレ）
	•	定義ID: A1_PREFIX_SUFFIX
	•	ロジック（複数行なら行Noで並べる想定）

IF(
  IFALL(
    LEFT({#1},1)={#2},
    RIGHT({#1},1)={#3}
  ),
  "A-1",
  ""
)

展開後は
LEFT({pcm_t_コンプラ相談.相談者部署CD},1)="A" のような式になり、既存の評価器にそのまま渡せます。

⸻

よくある詰まりポイント
	•	クォート忘れ：{#2} や {#3} に入れる "A", "1" はダブルクォート付きで渡すのが安全です。
	•	定義名の一致：Definitionsの「定義ID」と、| の左側の名前（ここでは A1_PREFIX_SUFFIX）が完全一致しているか確認。
	•	評価器の対応：LEFT/RIGHT を使う式は、前回ご提案の GetScalarValue / EvalOneCondition の拡張（LEFT/RIGHT/MID/LEN/LIKE等）を入れておくと確実です。

⸻

これで「Mappingの定義IDに引数を書き、Definitionsでテンプレを書く」運用がそのまま動きます。必要なら、区切り文字 | を別の記号に変えるのも簡単で、ParseDefId の Split を差し替えるだけです。