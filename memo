原因はCSV末尾の改行です。
あなたのパーサ（ParseCsvText）は、ループの中で vbLf に遭遇すると行を追加した後、ループ終了時に無条件で「最後の行」をもう一度追加しています。そのため「末尾が改行で終わるCSV」だと、空の最終行が1行余分に生成されます。

⸻

解決策（最小差分）

1) modIO の ParseCsvText を修正

ループ終了後の「最後の行を追加」部分を条件付きにします。
「行に1つでも値がある」「またはフィールドに文字がある」時だけ追加するようにすれば、末尾改行による空行は出ません。

' --- ここは既存 ---
For i = 1 To Len(txt)
    ' ...中略...
Next

' ★修正前
' row.Add field: rows.Add row

' ★修正後（空行抑止）
If (Len(field) > 0) Or (row.Count > 0) Then
    row.Add field
    rows.Add row
End If

該当箇所：ParseCsvText の終端部（現在は無条件で row.Add field: rows.Add row）です。

これで「末尾が改行で終わるCSV」でも空行は生成されません。
改行コードは既に CRLF/CR を LF に正規化しているので、この修正だけでOKです。

⸻

2)（補助）チャンク読込側の空行スキップ

ImportCsvChunked（行読み）経路を使う場合、もし本当に空の行を読み込んだら無視するガードも入れておくと堅牢です（Line Input #F, line → トリムして空ならスキップ）。呼び出しの骨子はこの通りです：ヘッダを読み、後はブロックに集めて貼る流れ。

⸻

3) それでも空行が残る場合
	•	CSV自体に完全な空行（区切りだけの行など）が混在していると、仕様上“データ行”として扱われます。必要なら「全列空の行は捨てる」フィルタを、配列化後に1回入れるのも手です（性能影響は軽微）。

⸻

なお：「初期状態でテーブルに1行あるから？」について

ImportCsvChunked 経路では、インポート前に FastClearTable でテーブルのデータ行を空にしてから書き込んでいるため、初期の1行が原因ではありません。余分な行は上記のパース時の末尾追加が主因です。

⸻

必要なら、この変更を適用した modIO.bas の差分ファイル形式でもすぐ用意します。