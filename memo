ありがとう、ここはもう潔く“単項マイナスの前処理ループ”をやめて、本体のパーサ側で単項マイナスを扱うほうが安定します。
（ご指摘の If cur="-" Then … If j=1 Then まわりは、式の形や全角/不可視文字の混入で落ちやすいです。）

下の 差し替え版 SafeEval は、
	•	短絡評価しない And 問題に非依存（配列参照の前に必ずカウントを確認）
	•	単項マイナスはパース時に「直前が演算子 or ‘(’ or 先頭」の -x を 0 - x として解釈（前処理ループ不要）
	•	スタック不足に強い（ApplyOp で nTop>=2 を保証）
	•	改行やタブを除去

という作りです。modJoinAndEval の既存 SafeEval/Precedence/ApplyOp を丸ごと置換してください。

⸻

置換用：安定版 SafeEval

Private Function SafeEval(ByVal expr As String) As Double
    ' 前処理：空白/改行/タブを除去
    expr = Replace$(expr, " ", "")
    expr = Replace$(expr, vbCr, "")
    expr = Replace$(expr, vbLf, "")
    expr = Replace$(expr, vbTab, "")
    If Len(expr) = 0 Then SafeEval = 0: Exit Function

    Dim nums() As Double, ops() As String, nTop As Long, oTop As Long
    ReDim nums(1 To 1): ReDim ops(1 To 1)
    nTop = 0: oTop = 0

    ' 直前トークン種別: 0=開始/なし, 1=数値 or ")",
    '                    2=演算子 or "("
    Dim prevKind As Integer: prevKind = 0

    Dim i As Long, ch As String, num As String
    i = 1
    Do While i <= Len(expr)
        ch = Mid$(expr, i, 1)

        ' 数値トークン（0-9 と小数点のみ）
        If ch Like "[0-9.]" Then
            num = ""
            Do While i <= Len(expr)
                ch = Mid$(expr, i, 1)
                If ch Like "[0-9.]" Then
                    num = num & ch
                    i = i + 1
                Else
                    Exit Do
                End If
            Loop
            nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
            On Error Resume Next
            nums(nTop) = CDbl(num)
            On Error GoTo 0
            prevKind = 1
            GoTo NEXTITER

        ElseIf ch = "(" Then
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2

        ElseIf ch = ")" Then
            ' "(" まで演算適用（短絡に頼らず段階評価）
            Do While oTop > 0
                If ops(oTop) = "(" Then
                    oTop = oTop - 1
                    Exit Do
                End If
                ApplyOp nums, nTop, ops, oTop
            Loop
            prevKind = 1

        ElseIf ch = "+" Or ch = "-" Or ch = "*" Or ch = "/" Then
            ' 単項マイナス: 先頭 or 直前が演算子/ "(" のときは 0 を前置して二項化
            If ch = "-" And (prevKind = 0 Or prevKind = 2) Then
                nTop = nTop + 1: ReDim Preserve nums(1 To nTop)
                nums(nTop) = 0
            Else
                ' 既存の演算子より優先度が低ければ先に適用
                Do While oTop > 0 And Precedence(ops(oTop)) >= Precedence(ch)
                    ApplyOp nums, nTop, ops, oTop
                Loop
            End If
            oTop = oTop + 1: ReDim Preserve ops(1 To oTop): ops(oTop) = ch
            prevKind = 2

        Else
            ' 想定外文字は無視（必要ならここでエラー扱いも可）
        End If

        i = i + 1
NEXTITER:
    Loop

    ' 残りの演算子を適用
    Do While oTop > 0
        ApplyOp nums, nTop, ops, oTop
    Loop

    If nTop > 0 Then
        SafeEval = nums(nTop)
    Else
        SafeEval = 0
    End If
End Function

Private Function Precedence(ByVal op As String) As Long
    Select Case op
        Case "+", "-": Precedence = 1
        Case "*", "/": Precedence = 2
        Case Else:     Precedence = 0
    End Select
End Function

Private Sub ApplyOp(ByRef nums() As Double, ByRef nTop As Long, _
                    ByRef ops() As String, ByRef oTop As Long)
    If oTop <= 0 Then Exit Sub
    Dim op As String: op = ops(oTop): oTop = oTop - 1

    If nTop < 2 Then Exit Sub   ' 片側不足の防御
    Dim b As Double, a As Double, r As Double
    b = nums(nTop): nTop = nTop - 1
    a = nums(nTop)

    Select Case op
        Case "+": r = a + b
        Case "-": r = a - b
        Case "*": r = a * b
        Case "/": If b = 0 Then r = 0 Else r = a / b
        Case Else: r = b
    End Select
    nums(nTop) = r
End Sub


⸻

使い方チェック（Immediate 窓）

? SafeEval("2+3")                           ' 5
? SafeEval("100+50+0+100+0+0")              ' 250
? SafeEval("(10+5)*2-3")                    ' 27
? SafeEval("-(5)+3")                        ' -2
? SafeEval("1+(-2)+3")                      ' 2
? SafeEval("10*-2+3")                       ' -17  （単項マイナスの乗算もOK：10* -2 + 3）


⸻

最後に念押し
	•	トークン置換側は実値の取得を必ず有効化
	•	ReplaceTokensWithRaw → valStr = ResolveTokenRaw(...) : valStr = ToNumberOrZero(valStr)
	•	ReplaceTokensProcessedAsNumber → valStr = ResolveTokenProcessed(...) : valStr = ToNumberOrZero(valStr)
	•	EvaluateExpr で Debug.Print "expr=" & expr, "res=" & res を一時的に入れると詰まり箇所が特定しやすいです。

これで ProcessData の落ちも解消し、res/acc に正しい合計が出るはず。試してみてください！