まだインデックスエラーが出ます。
Mapping_Mainのカラム構成はNo、出力カラム、データ型、キー、モード、定義ID、それ以降のカラムはインポートファイルのファイル名が並んでます。

modMappingHelperは次の通りです。

Option Explicit

'==============================
' Mappingテーブルを読み込み、Definitionsシートの定義IDから「定義」を復元する
' ・「定義」列は廃止（使わない）
' ・「定義ID」列は必須（空ならエラー）
' ・G列以降などの固定概念に依存せず、ヘッダー走査で元テーブル名の開始位置を自動検出
' 既存の公開配列（Map_*）はそのまま使用する前提：
'   Map_No(), Map_OutCols(), Map_DataType(), Map_Key(), Map_Mode(), Map_Def(), Map_TblNames(), Map_SrcCols(,)
'==============================
Public Function ReadMappingFromTableName(mapTableName As String) As Boolean
    On Error GoTo FAIL

    Dim lo As ListObject
    Set lo = GetListObjectByNameLocal(mapTableName)
    If lo Is Nothing Then
        MsgBox "Mappingテーブルが見つかりません: " & mapTableName, vbCritical
        ReadMappingFromTableName = False: Exit Function
    End If
    If lo.DataBodyRange Is Nothing Then
        MsgBox "Mappingテーブルにデータ行がありません: " & mapTableName, vbExclamation
        ReadMappingFromTableName = False: Exit Function
    End If

    '--- ヘッダー列の位置解決 ---
    Dim cNo As Long, cOut As Long, cType As Long, cKey As Long, cMode As Long
    Dim cDefId As Long

    cNo = FindHeaderIndexLocal(lo, "No")                            ' 任意（存在すれば読む）
    cOut = FindHeaderIndexLocal(lo, "出力カラム")
    If cOut = 0 Then cOut = FindHeaderIndexLocal(lo, "出力カラム名") ' 互換
    cType = FindHeaderIndexLocal(lo, "データ型")
    cKey = FindHeaderIndexLocal(lo, "キー")
    cMode = FindHeaderIndexLocal(lo, "モード")
    cDefId = FindHeaderIndexLocal(lo, "定義ID")                     ' 必須（ただしVALUE行は空OK）

    If cOut = 0 Or cType = 0 Or cKey = 0 Or cMode = 0 Or cDefId = 0 Then
        MsgBox "Mappingの見出しに不足があります（出力カラム／データ型／キー／モード／定義ID）", vbCritical
        ReadMappingFromTableName = False: Exit Function
    End If

    '--- 元テーブル名の開始位置を決定（固定列の最大の右隣） ---
    Dim maxFixed As Long
    maxFixed = Application.WorksheetFunction.Max(ArrayNZ(cNo), cOut, cType, cKey, cMode, cDefId)
    If maxFixed < 1 Then maxFixed = 6
    Dim firstColTable As Long: firstColTable = maxFixed + 1

    '--- ヘッダーから元テーブル名一覧を収集（空セルで打ち切り） ---
    Dim lastHeaderCol As Long: lastHeaderCol = lo.HeaderRowRange.Columns.Count
    Dim tn As String, dyn As New Collection
    Dim i As Long
    For i = firstColTable To lastHeaderCol
        tn = Trim$(CStr(lo.HeaderRowRange.Cells(1, i).Value))
        If Len(tn) = 0 Then Exit For
        dyn.Add tn
    Next
    If dyn.Count = 0 Then
        MsgBox "Mappingに元テーブル（定義ID列の右側）の見出しがありません。", vbCritical
        ReadMappingFromTableName = False: Exit Function
    End If

    '--- 配列確保 ---
    Dim rows As Long, cols As Long, t As Long, r As Long
    rows = lo.DataBodyRange.rows.Count
    cols = dyn.Count

    ReDim Map_No(1 To rows)
    ReDim Map_OutCols(1 To rows)
    ReDim Map_DataType(1 To rows)
    ReDim Map_Key(1 To rows)
    ReDim Map_Mode(1 To rows)
    ReDim Map_Def(1 To rows)
    ReDim Map_TblNames(1 To cols)
    ReDim Map_SrcCols(1 To rows, 1 To cols)

    For t = 1 To cols
        Map_TblNames(t) = CStr(dyn(t))
    Next

    '--- 本体読み込み ---
    Dim body As Range: Set body = lo.DataBodyRange
    Dim defId As String, defText As String, modeVal As String

    For r = 1 To rows
        If cNo > 0 Then Map_No(r) = body.Cells(r, cNo).Value
        Map_OutCols(r) = Trim$(CStr(body.Cells(r, cOut).Value))
        Map_DataType(r) = UCase$(Trim$(CStr(body.Cells(r, cType).Value)))
        Map_Key(r) = UCase$(Trim$(CStr(body.Cells(r, cKey).Value)))
        Map_Mode(r) = UCase$(Trim$(CStr(body.Cells(r, cMode).Value)))

        modeVal = Map_Mode(r)
        defId = Trim$(CStr(body.Cells(r, cDefId).Value))

        If Len(defId) = 0 Then
            If modeVal = "VALUE" Then
                defText = ""   ' VALUEは加工なし（Definitions参照不要）
            Else
                MsgBox "定義IDが未入力ですが、モード=" & modeVal & " の行があります。" & vbCrLf & _
                       "No=" & CStr(IIf(cNo > 0, body.Cells(r, cNo).Value, r)), vbCritical
                ReadMappingFromTableName = False: Exit Function
            End If
        Else
            On Error GoTo DEF_ERR
            defText = BuildDefinitionFromSheet(defId)   ' Definitionsから復元
            On Error GoTo FAIL
        End If

        Map_Def(r) = defText

        ' 元カラム群
        For t = 1 To cols
            Map_SrcCols(r, t) = CStr(body.Cells(r, firstColTable - 1 + t).Value)
        Next
    Next r

    ReadMappingFromTableName = True
    Exit Function

DEF_ERR:
    MsgBox "Definitions参照に失敗しました。定義ID=" & defId & " / " & Err.Description, vbCritical
    ReadMappingFromTableName = False
    Exit Function

FAIL:
    MsgBox "ReadMappingFromTableName でエラー: " & Err.Description, vbCritical
    ReadMappingFromTableName = False
End Function

'==================== ローカルユーティリティ ====================

Private Function GetListObjectByNameLocal(nameOrRange As String) As ListObject
    Dim ws As Worksheet, lo As ListObject
    For Each ws In ThisWorkbook.Worksheets
        For Each lo In ws.ListObjects
            If StrComp(lo.name, nameOrRange, vbTextCompare) = 0 Then
                Set GetListObjectByNameLocal = lo
                Exit Function
            End If
        Next
    Next
    Set GetListObjectByNameLocal = Nothing
End Function

Private Function FindHeaderIndexLocal(lo As ListObject, headerName As String) As Long
    Dim i As Long, s As String
    For i = 1 To lo.HeaderRowRange.Columns.Count
        s = Trim$(CStr(lo.HeaderRowRange.Cells(1, i).Value))
        If StrComp(s, headerName, vbTextCompare) = 0 Then
            FindHeaderIndexLocal = i
            Exit Function
        End If
    Next
    FindHeaderIndexLocal = 0
End Function

' WorksheetFunction.Max は配列の空(=0)が混じると不便なので0→無視の代替
Private Function ArrayNZ(v As Variant) As Long
    If IsNumeric(v) Then
        ArrayNZ = CLng(v)
    Else
        ArrayNZ = 0
    End If
End Function

'==============================
' キー索引（Single: 1件、Multi: 複数行）堅牢版
'==============================
Public Sub BuildKeyIndexes()
    ' 親辞書（テーブル名 -> 単一行辞書 / 複数行辞書）を初期化
    Set KeyIndexSingle = CreateObject("Scripting.Dictionary")
    Set KeyIndexMulti = CreateObject("Scripting.Dictionary")
    
    Dim t As Long
    If (Not Not Map_TblNames) = 0 Then Exit Sub ' テーブル名未定義なら何もしない
    
    For t = LBound(Map_TblNames) To UBound(Map_TblNames)
        Dim tblName As String: tblName = Map_TblNames(t)
        Dim arr As Variant
        
        ' 1) テーブルが読み込まれているか？
        If Not TableData.Exists(tblName) Then
            WriteLog "ERROR", "BuildKeyIndexes: table not loaded: " & tblName
            KeyIndexSingle(tblName) = CreateObject("Scripting.Dictionary")
            KeyIndexMulti(tblName) = CreateObject("Scripting.Dictionary")
            GoTo CONT_T
        End If
        
        arr = TableData(tblName)
        ' 2) 配列で、かつ2次元か？
        If Not IsArray(arr) Then
            WriteLog "ERROR", "BuildKeyIndexes: table is not array: " & tblName
            KeyIndexSingle(tblName) = CreateObject("Scripting.Dictionary")
            KeyIndexMulti(tblName) = CreateObject("Scripting.Dictionary")
            GoTo CONT_T
        End If
        On Error GoTo BAD_ARRAY
        Dim rUB1 As Long, rUB2 As Long
        rUB1 = UBound(arr, 1): rUB2 = UBound(arr, 2)
        On Error GoTo 0
        If rUB1 < 2 Or rUB2 < 1 Then
            WriteLog "ERROR", "BuildKeyIndexes: invalid array shape: " & tblName
            KeyIndexSingle(tblName) = CreateObject("Scripting.Dictionary")
            KeyIndexMulti(tblName) = CreateObject("Scripting.Dictionary")
            GoTo CONT_T
        End If
        
        ' 3) このテーブルで使うキー列ヘッダーの位置を集める
        Dim keyColIdx() As Long, kc As Long: kc = 0
    
        Dim hasIsKey As Boolean, hasSrc As Boolean
        Dim lbIs As Long, ubIs As Long, lb2 As Long, ub2 As Long, tAdj As Long
    
        On Error Resume Next
        lbIs = LBound(Map_IsKey): ubIs = UBound(Map_IsKey)
        hasIsKey = (Err.Number = 0)
        Err.Clear
    
        lb2 = LBound(Map_SrcCols, 2): ub2 = UBound(Map_SrcCols, 2)
        hasSrc = (Err.Number = 0)
        Err.Clear
        On Error GoTo 0
    
        If Not hasIsKey Or Not hasSrc Then
            WriteLog "WARN", "BuildKeyIndexes: Map_IsKey or Map_SrcCols not initialized. table=" & tblName
            GoTo CONT_T
        End If
    
        ' Map_TblNames が 0 始まり、Map_SrcCols の第2次元が 1 始まりのケースを吸収
        If lb2 = 1 And LBound(Map_TblNames) = 0 Then
            tAdj = t + 1
        Else
            tAdj = t
        End If
    
        If tAdj < lb2 Or tAdj > ub2 Then
            WriteLog "WARN", "BuildKeyIndexes: table index out of srcCols bound. table=" & tblName & " tAdj=" & tAdj
            GoTo CONT_T
        End If
    
        Dim i As Long
        For i = lbIs To ubIs
            If Map_IsKey(i) Then
                Dim srcCol As String
                On Error Resume Next
                srcCol = Trim$(CStr(Map_SrcCols(i, tAdj)))
                If Err.Number <> 0 Then srcCol = ""
                Err.Clear
                On Error GoTo 0
    
                If Len(srcCol) > 0 Then
                    Dim idx As Long: idx = FindColumnIndex(arr, srcCol)
                    If idx > 0 Then
                        kc = kc + 1
                        ReDim Preserve keyColIdx(1 To kc)
                        keyColIdx(kc) = idx
                    Else
                        WriteLog "WARN", "BuildKeyIndexes: key column not found. table=" & tblName & " col=" & srcCol
                    End If
                End If
            End If
        Next i
    
        '=== 4) 実際にキーを作る（既存のまま） ===
        Dim dict1 As Object, dictM As Object
        Set dict1 = CreateObject("Scripting.Dictionary") ' 単一行（最初の1件）
        Set dictM = CreateObject("Scripting.Dictionary") ' 複数行（全件、Collection）
    
        If kc > 0 Then
            Dim r As Long, keyStr As String
            For r = 2 To rUB1
                keyStr = BuildKeyFromRow(arr, r, keyColIdx)
                If Len(keyStr) > 0 Then
                    If Not dict1.Exists(keyStr) Then dict1.Add keyStr, r
                    If Not dictM.Exists(keyStr) Then dictM.Add keyStr, New Collection
                    dictM(keyStr).Add r
                End If
            Next
        Else
            WriteLog "WARN", "BuildKeyIndexes: no key columns collected for table=" & tblName
        End If
    
        Set KeyIndexSingle(tblName) = dict1
        Set KeyIndexMulti(tblName) = dictM
        
CONT_T:
        ' 次のテーブルへ
    Next
    Exit Sub

BAD_ARRAY:
    On Error GoTo 0
    WriteLog "ERROR", "BuildKeyIndexes: UBound failed (not 2D array?) table=" & Map_TblNames(t)
    KeyIndexSingle(Map_TblNames(t)) = CreateObject("Scripting.Dictionary")
    KeyIndexMulti(Map_TblNames(t)) = CreateObject("Scripting.Dictionary")
End Sub

'=== ヘッダ正規化 & 列番号探し（共通） ===
Private Function Norm(ByVal s As String) As String
    If Len(s) = 0 Then Norm = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "") ' UTF-8 BOM
    s = Trim$(s)
    Norm = s
End Function

Public Function FindColumnIndex(arr As Variant, ColName As String) As Long
    Dim c As Long, target As String
    target = Norm(ColName)
    For c = 1 To UBound(arr, 2)
        If Norm(CStr(arr(1, c))) = target Then
            FindColumnIndex = c
            Exit Function
        End If
    Next
    FindColumnIndex = 0
End Function


'==============================
' ベーステーブル選定（キー定義が成立している最初のテーブル。無ければ先頭）
'  - tblNames : H列以降のテーブル名配列 Map_TblNames()
'  - srcCols  : マッピングの元カラム   Map_SrcCols(行=出力列, 列=テーブル)
'  - isKey    : キー列フラグ配列       Map_IsKey()
' 返り値      : ベーステーブル名（空配列時は ""）
'==============================
Public Function PickBaseTableName(tblNames() As String, srcCols As Variant, isKey() As Boolean) As String
    Dim t As Long, i As Long
    ' テーブル名が未設定なら空を返す
    If (Not Not tblNames) = 0 Then
        PickBaseTableName = ""
        Exit Function
    End If
    
    ' どれか1つでも「キー=○」かつ該当テーブルに元カラムが指定されている最初のテーブルを採用
    For t = LBound(tblNames) To UBound(tblNames)
        For i = LBound(isKey) To UBound(isKey)
            If isKey(i) Then
                ' srcCols(行=i, 列=t) が範囲内か確認
                If (Not IsEmpty(srcCols)) Then
                    On Error Resume Next
                    Dim hasCol As Boolean
                    hasCol = (Len(Trim$(CStr(srcCols(i, t)))) > 0)
                    On Error GoTo 0
                    If hasCol Then
                        PickBaseTableName = tblNames(t)
                        Exit Function
                    End If
                End If
            End If
        Next i
    Next t
    
    ' 上で見つからなければ、先頭を採用
    PickBaseTableName = tblNames(LBound(tblNames))
End Function
