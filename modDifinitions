Option Explicit
'============================================================
' modDifinitions
' 概要: Definitionsシートから定義IDに紐付くロジックテンプレートを復元・展開する機能
'============================================================


' Definitionsシートから「定義ID」に対応するロジック群を連結して返す
' シート要件（ListObject名："Definitions" 推奨）：
'   見出し： 定義ID / バージョン(任意) / 行No / ロジック / （備考 任意）
'   - 同じ定義IDの中で、最大のバージョン番号を採用（バージョン列がなければ全行対象）
'   - 行No昇順で「ロジック」を vbLf 連結して返却

'--- BuildDefinitionFromSheet ---
' 概要: Definitionsシートから定義IDに対応するロジックを復元して返します。
' 引数:
'   defIdRaw As String  … 定義ID（引数付き 'ID(arg1, arg2,...)' も可）
'   Optional definitionsListName As String = "Definitions"  … 用途を指定

Public Function BuildDefinitionFromSheet(defIdRaw As String, Optional definitionsListName As String = "Definitions") As String
    On Error GoTo ERR_HANDLER

    Dim defName As String
    Dim params As Object
    Dim logicTemplate As String
    Dim expanded As String

    ' --- 1. 定義名と引数を抽出 ---
    Set params = CreateObject("Scripting.Dictionary")
    ParseDefinitionCall defIdRaw, defName, params

    If Len(defName) = 0 Then
        BuildDefinitionFromSheet = ""
        Exit Function
    End If

    ' --- 2. Definitionsシートからテンプレート取得 ---
    logicTemplate = BuildDefinitionTemplateFromSheet(defName, definitionsListName)
    If Len(logicTemplate) = 0 Then
        Err.Raise vbObjectError + 9001, , "Definitions参照に失敗しました: 定義ID=[" & defName & "]"
    End If

    ' --- 3. テンプレ内の {paramX} を展開 ---
    expanded = ExpandNamedParams(logicTemplate, params)

    BuildDefinitionFromSheet = expanded
    Exit Function

ERR_HANDLER:
    MsgBox "BuildDefinitionFromSheet エラー: " & Err.Description, vbCritical
    BuildDefinitionFromSheet = ""
End Function


' Definitionsシートから指定定義名のロジック（テンプレ）を取得

'--- BuildDefinitionTemplateFromSheet ---
' 概要: Definitionsから指定定義名のテンプレート（行No順結合）を取得
' 引数:
'   defName As String  … 定義名
'   Optional definitionsListName As String = "Definitions"  … 用途を指定

Private Function BuildDefinitionTemplateFromSheet(defName As String, Optional definitionsListName As String = "Definitions") As String
    Dim lo As ListObject
    Set lo = GetListObjectByNameEx(definitionsListName)
    If lo Is Nothing Then
        Err.Raise vbObjectError + 3401, , "Definitionsテーブル(" & definitionsListName & ")が見つかりません。"
    End If
    If lo.DataBodyRange Is Nothing Then BuildDefinitionTemplateFromSheet = "": Exit Function

    ' ヘッダー列取得
    Dim cId As Long, cVer As Long, cLine As Long, cLogic As Long
    cId = FindHeaderIndexEx(lo, "定義ID")
    cVer = FindHeaderIndexEx(lo, "バージョン")
    cLine = FindHeaderIndexEx(lo, "行No")
    cLogic = FindHeaderIndexEx(lo, "ロジック")

    If cId = 0 Or cLine = 0 Or cLogic = 0 Then
        Err.Raise vbObjectError + 3402, , "Definitionsの見出しが不正です。定義ID／行No／ロジック が必要です。"
    End If

    ' 最大バージョンを取得
    Dim maxVer As Long
    maxVer = MaxVersionForIdEx(lo, cId, cVer, defName)

    ' 行No昇順にロジックを結合
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    Dim r As Range, idv As String, vv As Variant, lineNo As Long, logicText As String

    For Each r In lo.DataBodyRange.rows
        idv = CStr(r.Cells(1, cId).Value)
        If StrComp(idv, defName, vbTextCompare) = 0 Then
            If cVer > 0 Then
                vv = r.Cells(1, cVer).Value
                If IsNumeric(vv) Then
                    If CLng(vv) <> maxVer Then GoTo CONT_ROW
                Else
                    GoTo CONT_ROW
                End If
            End If

            vv = r.Cells(1, cLine).Value
            If Not IsNumeric(vv) Then GoTo CONT_ROW
            lineNo = CLng(vv)

            logicText = CStr(r.Cells(1, cLogic).Value)
            If Len(Trim$(logicText)) = 0 Then GoTo CONT_ROW

            dict(lineNo) = logicText
        End If
CONT_ROW:
    Next

    If dict.Count = 0 Then BuildDefinitionTemplateFromSheet = "": Exit Function

    ' 行No昇順で連結
    Dim keys() As Variant, i As Long, j As Long, tmp As Variant, acc As String
    keys = dict.keys
    For i = LBound(keys) To UBound(keys) - 1
        For j = i + 1 To UBound(keys)
            If CLng(keys(i)) > CLng(keys(j)) Then
                tmp = keys(i): keys(i) = keys(j): keys(j) = tmp
            End If
        Next
    Next

    For i = LBound(keys) To UBound(keys)
        If Len(acc) > 0 Then acc = acc & vbLf
        acc = acc & dict(keys(i))
    Next

    BuildDefinitionTemplateFromSheet = acc
End Function

' 解析:  定義ID(引数1, 引数2, ...) → 定義名と引数Dictionaryに展開

'--- ParseDefinitionCall ---
' 概要:
' 引数:
'   ByVal src As String  …
'   ByRef defName As String  …
'   ByRef params As Object  …
Private Sub ParseDefinitionCall(ByVal src As String, ByRef defName As String, ByRef params As Object)
    Dim openPos As Long, closePos As Long, argStr As String, parts As Variant, i As Long

    src = Trim$(src)
    openPos = InStr(src, "(")
    closePos = InStrRev(src, ")")

    If openPos = 0 Or closePos = 0 Or closePos < openPos Then
        ' 引数なし
        defName = src
        Exit Sub
    End If

    defName = Trim$(Left$(src, openPos - 1))
    argStr = Mid$(src, openPos + 1, closePos - openPos - 1)

    If Len(argStr) = 0 Then Exit Sub

    parts = Split(argStr, ",")
    For i = LBound(parts) To UBound(parts)
        params("param" & (i + 1)) = Trim$(parts(i))
    Next i
End Sub

' テンプレ内の {param1}, {param2}, ... を展開

'--- ExpandNamedParams ---
' 概要:
' 引数:
'   ByVal template As String  …
'   ByRef params As Object  …
Private Function ExpandNamedParams(ByVal template As String, ByRef params As Object) As String
    Dim k As Variant, s As String
    s = template
    For Each k In params.keys
        s = Replace$(s, "{" & k & "}", params(k))
    Next k
    ExpandNamedParams = s
End Function


'==================== ユーティリティ（このモジュール内限定名） ====================

'--- GetListObjectByNameEx ---
' 概要:
' 引数:
'   nameOrRange As String  …

Private Function GetListObjectByNameEx(nameOrRange As String) As ListObject
    Dim ws As Worksheet, lo As ListObject
    For Each ws In ThisWorkbook.Worksheets
        For Each lo In ws.ListObjects
            If StrComp(lo.name, nameOrRange, vbTextCompare) = 0 Then
                Set GetListObjectByNameEx = lo
                Exit Function
            End If
        Next
    Next
    Set GetListObjectByNameEx = Nothing
End Function


'--- FindHeaderIndexEx ---
' 概要: 指定されたテーブル(ListObject)のヘッダー行から、列名(headerName)が一致する列番号を取得する。
'       一致が見つからなければ0を返す。
' 引数:
'   lo As ListObject  … 検索対象となるExcelテーブル(ListObject)
'   headerName As String  … 探したいヘッダー(列名)の文字列

Private Function FindHeaderIndexEx(lo As ListObject, headerName As String) As Long
    Dim i As Long, s As String
    For i = 1 To lo.HeaderRowRange.Columns.Count
        s = Trim$(CStr(lo.HeaderRowRange.Cells(1, i).Value))
        If StrComp(s, headerName, vbTextCompare) = 0 Then
            FindHeaderIndexEx = i
            Exit Function
        End If
    Next
    FindHeaderIndexEx = 0
End Function


'--- MaxVersionForIdEx ---
' 概要: 指定されたテーブル(ListObject)内で、対象ID(defId)に一致する行を検索し、
'       バージョン列(idxVer)の最大値を取得して返す。該当がない場合は1を返す。
' 引数:
'   lo As ListObject  … 検索対象となるExcelテーブル(ListObject)
'   idxId As Long  … IDが格納された列番号 (1始まり)
'   idxVer As Long  … バージョン番号が格納された列番号 (1始まり、0以下なら無効)
'   defId As String  … 最大バージョンを求める対象のID文字列

Private Function MaxVersionForIdEx(lo As ListObject, idxId As Long, idxVer As Long, defId As String) As Long
    Dim maxv As Long: maxv = 1
    Dim r As Range, v As Variant, idv As String, vv As Variant
    If lo.DataBodyRange Is Nothing Then MaxVersionForIdEx = 1: Exit Function

    For Each r In lo.DataBodyRange.rows
        v = r.Cells(1, idxId).Value
        idv = CStr(v)
        If StrComp(idv, defId, vbTextCompare) = 0 Then
            If idxVer > 0 Then
                vv = r.Cells(1, idxVer).Value
                If IsNumeric(vv) Then
                    If CLng(vv) > maxv Then maxv = CLng(vv)
                End If
            End If
        End If
    Next
    MaxVersionForIdEx = maxv
End Function
