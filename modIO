Option Explicit
'============================================================
' modIO
' 概要: CSV読み書き・文字コード判定・区切り文字検出・テキストI/O・フォルダ作成などの入出力ユーティリティ。
'============================================================

'=== 区切り文字の簡易自動判定（1行目のみ・クォート内は概ね考慮） ===

'--- DetectDelimiterFromText ---
' 概要: CSV先頭行から推定して区切り文字（カンマ/タブ/セミコロン）を返します。
' 引数:
'   ByVal txt As String  … CSVテキスト（先頭行を参照）
' 概要: CSV テキストから区切り文字（カンマ/タブ/セミコロン等）を推定します。
' 引数:
'   text As String  … 判定対象テキスト
' 戻り値: 推定された区切り文字（単一文字）
Private Function DetectDelimiterFromText(ByVal txt As String) As String
    Dim firstLine As String, p As Long
    p = InStr(txt, vbLf)
    If p = 0 Then firstLine = txt Else firstLine = Left$(txt, p - 1)

    Dim i As Long, ch As String * 1, inQ As Boolean, q As String * 1
    Dim cntComma As Long, cntTab As Long, cntSemi As Long
    For i = 1 To Len(firstLine)
        ch = Mid$(firstLine, i, 1)
        If ch = """" Or ch = "'" Then
            If inQ Then
                If ch = q Then inQ = False
            Else
                inQ = True: q = ch
            End If
        ElseIf Not inQ Then
            If ch = "," Then cntComma = cntComma + 1
            If ch = vbTab Then cntTab = cntTab + 1
            If ch = ";" Then cntSemi = cntSemi + 1
        End If
    Next
 
    If (cntTab >= cntComma) And (cntTab >= cntSemi) Then
        DetectDelimiterFromText = vbTab
    ElseIf cntComma >= cntSemi Then
        DetectDelimiterFromText = ","
    Else
        DetectDelimiterFromText = ";"
    End If

End Function

' フォルダ作成（存在しなければ作成）

'--- EnsureFolder ---
' 概要: 存在しない場合はフォルダを作成します。末尾'\'を許容。
' 引数:
'   ByVal pathWithSlash As String  … 作成したいフォルダのパス（末尾に'\'推奨）
' 概要: フォルダが存在しなければ作成します（多階層に対応）。
' 引数:
'   folderPath As String  … 作成/確認するフォルダパス
Public Sub EnsureFolder(ByVal pathWithSlash As String)
    On Error Resume Next
    If Right$(pathWithSlash, 1) <> "\" Then pathWithSlash = pathWithSlash & "\"
    If Len(Dir(pathWithSlash, vbDirectory)) = 0 Then MkDir pathWithSlash
    On Error GoTo 0
End Sub

' CSV 読み込み（文字コード対応）

'--- ParseCsvFile ---
' 概要: CSVファイルを読み込み、2次元配列（ヘッダ含む）にして返します。
' 引数:
'   filePath As String  … 読み込むCSVのフルパス
Public Function ParseCsvFile(filePath As String) As Variant
    Dim txt As String
    txt = ReadTextFile(filePath, CurrentEncodingMode) ' AUTO/UTF-8/SHIFT_JIS/UTF-16LE
    ParseCsvFile = ParseCsvText(txt)
End Function

' RFC4180 簡易：ダブルクォートと改行を処理

'--- ParseCsvText ---
' 概要: CSVテキストを解析して2次元配列（ヘッダ含む）に変換します。
' 引数:
'   ByVal txt As String  … CSV全体の文字列
Public Function ParseCsvText(ByVal txt As String) As Variant
    Dim delim As String
    delim = DetectDelimiterFromText(txt)  ' ★ 自動判定

    Dim i As Long, ch As String * 1, d As String
    Dim inQuote As Boolean
    Dim field As String, row As Collection, rows As Collection
    Set rows = New Collection: Set row = New Collection
    field = "": inQuote = False

    ' 改行統一
    txt = Replace$(txt, vbCrLf, vbLf)
    txt = Replace$(txt, vbCr, vbLf)

    For i = 1 To Len(txt)
        ch = Mid$(txt, i, 1)
        If inQuote Then
            If ch = """" Then
                If i < Len(txt) And Mid$(txt, i + 1, 1) = """" Then
                    field = field & """": i = i + 1
                Else
                    inQuote = False
                End If
            Else
                field = field & ch
            End If
        Else
            d = Mid$(delim, 1, 1)
            Select Case ch
                Case """": inQuote = True
                Case d:   row.Add field: field = ""
                Case vbLf: row.Add field: field = "": rows.Add row: Set row = New Collection
                Case Else: field = field & ch
            End Select
        End If
    Next
'    row.Add field: rows.Add row
    If (Len(field) > 0) Or (row.Count > 0) Then
        row.Add field
        rows.Add row
    End If

    Dim maxCol As Long, r As Long
    For r = 1 To rows.Count
        If rows(r).Count > maxCol Then maxCol = rows(r).Count
    Next
    Dim result() As Variant, rr As Long, cc As Long
    If rows.Count = 0 Then
        ReDim result(1 To 1, 1 To 1): result(1, 1) = ""
        ParseCsvText = result: Exit Function
    End If
    ReDim result(1 To rows.Count, 1 To maxCol)
    For rr = 1 To rows.Count
        For cc = 1 To rows(rr).Count
            result(rr, cc) = rows(rr)(cc)
        Next
        For cc = rows(rr).Count + 1 To maxCol
            result(rr, cc) = ""
        Next
    Next
    ParseCsvText = result
End Function

' 文字コード：読み（ADODB.Stream + BOM検出）

'--- ReadTextFile ---
' 概要: 指定エンコードでテキストファイルを読み込みます（AUTOはBOM検出）。
' 引数:
'   filePath As String  … ファイルパス
'   encMode As String  … AUTO/UTF-8/SHIFT_JIS/UTF-16LE
Public Function ReadTextFile(filePath As String, encMode As String) As String
    Dim mode As String: mode = UCase$(encMode)
    If mode = "AUTO" Or Len(mode) = 0 Then mode = DetectEncoding(filePath)
    
    Dim stm As Object ' ADODB.Stream
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "shift_jis"
    End Select
    stm.Open
    stm.LoadFromFile filePath
    ReadTextFile = stm.ReadText(-1)
    stm.Close
    Set stm = Nothing
End Function

'--- DetectEncoding ---
' 概要: BOMから推定されるエンコード種別を返します。
' 引数:
'   filePath As String  … ファイルパス

Public Function DetectEncoding(filePath As String) As String
    Dim F As Integer, b1 As Byte, b2 As Byte, b3 As Byte
    On Error GoTo FAIL
    F = FreeFile
    Open filePath For Binary As #F
    If LOF(F) >= 2 Then
        Get #F, , b1: Get #F, , b2
        If b1 = &HEF And b2 = &HBB And LOF(F) >= 3 Then
            Get #F, , b3
            If b3 = &HBF Then DetectEncoding = "UTF-8": Close #F: Exit Function
        ElseIf b1 = &HFF And b2 = &HFE Then
            DetectEncoding = "UTF-16LE": Close #F: Exit Function
        End If
    End If
    Close #F
FAIL:
    If Len(DetectEncoding) = 0 Then DetectEncoding = "SHIFT_JIS"
End Function

' 文字コード：書き（ADODB.Stream）

'--- WriteTextFile ---
' 概要: 指定エンコードでテキストを書き出します。
' 引数:
'   filePath As String  … 出力先パス
'   ByVal content As String  … 書き出す文字列
'   encMode As String  … AUTO/UTF-8/SHIFT_JIS/UTF-16LE（AUTOはUTF-8(BOM)）
' 概要: テキストを指定エンコードで書き出します。既存ファイルは上書き。
' 引数:
'   filePath As String  … 出力ファイルパス
'   text As String  … 出力する内容
'   encodingName As String  … テキストエンコード名
Public Sub WriteTextFile(filePath As String, ByVal content As String, encMode As String)
    Dim stm As Object ' ADODB.Stream
    Dim mode As String: mode = UCase$(encMode)
    If mode = "AUTO" Or Len(mode) = 0 Then mode = "UTF-8" ' AUTOはUTF-8(BOM)で出力
    
    Set stm = CreateObject("ADODB.Stream")
    stm.Type = 2 ' text
    Select Case mode
        Case "UTF-8":     stm.Charset = "utf-8"
        Case "UTF-16LE":  stm.Charset = "unicode"
        Case "SHIFT_JIS": stm.Charset = "shift_jis"
        Case Else:        stm.Charset = "utf-8"
    End Select
    stm.Open
    stm.WriteText content
    stm.SaveToFile filePath, 2 ' adSaveCreateOverWrite
    stm.Close
    Set stm = Nothing
End Sub

' importFiles から必要CSVを読み込む

'--- LoadAllCsv ---
' 概要: この手続きの役割を説明します。
' 引数:
'   importPath As String  … 用途を指定します。
' _
                           tblNames(  … 用途を指定します。
' 概要: Import フォルダ配下の CSV を一括読み込みし、テーブル名→配列（ヘッダ付）へ変換します。
' 戻り値: Scripting.Dictionary（Key: テーブル名 → Value: Variant(2次元配列)）
' 備考: 区切りは DetectDelimiterFromText で自動推定。
Public Function LoadAllCsv(importPath As String, _
                           tblNames() As String, _
                           ByRef dict As Object) As Boolean
    On Error GoTo FAIL

    Dim i As Long
    If (Not Not tblNames) = 0 Then
        MsgBox "読み込むテーブルがありません（Mapping未読か空）", vbExclamation
        LoadAllCsv = False
        Exit Function
    End If

    If Dir(importPath, vbDirectory) = "" Then
        MsgBox "入力フォルダが存在しません：" & importPath, vbCritical
        LoadAllCsv = False
        Exit Function
    End If

    ' フォルダ内CSVの索引（小文字ベース名→フルパス）を作る
    Dim idx As Object: Set idx = CreateObject("Scripting.Dictionary")
    Dim F As String, base As String
    F = Dir(importPath & "*.csv")
    Do While Len(F) > 0
        base = LCase$(Left$(F, InStrRev(F, ".") - 1))   ' 拡張子除去
        idx(base) = importPath & F                       ' 同名は後勝ちでOK
        F = Dir()
    Loop

    ' 要求テーブルだけ読み込む
    For i = LBound(tblNames) To UBound(tblNames)
        Dim t As String, key As String, fp As String
        t = CStr(tblNames(i))
        key = LCase$(t)
        If idx.Exists(key) Then
            fp = idx(key)
            Dim arr As Variant
            arr = ParseCsvFile(fp)
            ' 既に存在しても上書きにする（Add→Assign）
            dict(t) = arr
            WriteLog "INFO", "Loaded CSV: " & t & "  rows=" & IIf(IsArray(arr), UBound(arr, 1) - 1, 0)
        Else
            ' 必須テーブルが見つからない場合はエラー（必要ならここをWARNに変更可）
            WriteLog "ERROR", "CSV not found for table: " & t
            MsgBox "CSVファイルが見つかりません: " & t & vbCrLf & _
                   "ファイル名は '" & t & ".csv' を想定しています。", vbCritical
            LoadAllCsv = False
            Exit Function
        End If
    Next

    LoadAllCsv = True
    Exit Function
FAIL:
    WriteLog "ERROR", "LoadAllCsv error: " & Err.Number & " " & Err.Description
    MsgBox "LoadAllCsvでエラー: " & Err.Description, vbCritical
    LoadAllCsv = False
End Function

' テーブル（ListObject）を探すユーティリティ

'--- GetListObjectByName ---
' 概要: この手続きの役割を説明します。
' 引数:
'   tableName As String  … 用途を指定します。
' 概要: アクティブブックから ListObject 名で検索し最初に見つかったものを返します。
' 引数:
'   name As String  … ListObject 名
' 戻り値: ListObject / 見つからない場合 Nothing
Public Function GetListObjectByName(tableName As String) As ListObject
    Dim ws As Worksheet, lo As ListObject
    For Each ws In ThisWorkbook.Worksheets
        For Each lo In ws.ListObjects
            If lo.name = tableName Then
                Set GetListObjectByName = lo
                Exit Function
            End If
        Next
    Next
    Set GetListObjectByName = Nothing
End Function
