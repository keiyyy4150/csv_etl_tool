Option Explicit
'============================================================
' modJoinAndEval
' 概要: JOINインデックス利用、EXPR評価（IF/数式/テンプレ/LOOKUP）、型最終化 など
'============================================================

' ※ 既存の依存:
' - TableData, KeyIndexMulti, Map_* 系配列, AllowOneToMany（modGlobals）
' - FindColumnIndex（modMappingHelper）
' - WriteLog / Logger は modLogger 側（ここでは参照のみ）
' - SafeEval / ApplyTemplate / HasIFSyntax / EvalIFLine / FinalizeByType / NumVal など既存関数

'======================
' ここから追加: LOOKUP
'======================

'--- EnsureLookupIndex ---
' 概要: 指定テーブル×検索列の値→行番号インデックスを構築/取得
Private Function EnsureLookupIndex(tbl As String, findCol As String) As Object
    If LookupIndex Is Nothing Then Set LookupIndex = CreateObject("Scripting.Dictionary")
    Dim k As String: k = tbl & "|" & findCol
    If LookupIndex.Exists(k) Then
        Set EnsureLookupIndex = LookupIndex(k)
        Exit Function
    End If

    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    If TableData Is Nothing Then GoTo REG
    If Not TableData.Exists(tbl) Then GoTo REG

    Dim arr As Variant: arr = TableData(tbl)
    Dim cFind As Long: cFind = FindColumnIndex(arr, findCol)
    If cFind > 0 Then
        Dim r As Long, lb As Long, ub As Long
        lb = LBound(arr, 1): ub = UBound(arr, 1)
        For r = lb + 1 To ub
            Dim v As String: v = CStr(arr(r, cFind))
            If Not dict.Exists(v) Then dict.Add v, r  ' 同値複数は先勝ち
        Next
    End If
REG:
    LookupIndex(k) = dict
    Set EnsureLookupIndex = dict
End Function

'--- GetValueByColumn ---
' 概要: tbl の findCol = findVal に一致する最初の行の retCol を返す（無ければ ""）
Private Function GetValueByColumn(tbl As String, findCol As String, findVal As String, retCol As String) As String
    On Error GoTo SAFE
    If TableData Is Nothing Then Exit Function
    If Not TableData.Exists(tbl) Then Exit Function

    Dim arr As Variant: arr = TableData(tbl)
    Dim cRet As Long
    If IsNumeric(retCol) Then
        cRet = CLng(retCol)
    Else
        cRet = FindColumnIndex(arr, retCol)
    End If
    If cRet = 0 Then Exit Function

    ' まずはインデックス参照（高速）
    Dim idx As Object: Set idx = EnsureLookupIndex(tbl, findCol)
    Dim key As String: key = CStr(findVal)
    If idx.Exists(key) Then
        GetValueByColumn = CStr(arr(idx(key), cRet))
        Exit Function
    End If

    ' インデックスに無い場合は線形スキャン（安全策）
    Dim cFind As Long: cFind = FindColumnIndex(arr, findCol)
    If cFind = 0 Then Exit Function

    Dim r As Long, lb As Long, ub As Long
    lb = LBound(arr, 1): ub = UBound(arr, 1)
    For r = lb + 1 To ub
        If CStr(arr(r, cFind)) = key Then
            GetValueByColumn = CStr(arr(r, cRet))
            Exit Function
        End If
    Next
SAFE:
End Function

'--- SplitArgs ---
' 概要: 関数風文字列の引数をカンマで分割（括弧/クォート内のカンマは無視）
Private Function SplitArgs(ByVal inside As String) As Collection
    Dim col As New Collection
    Dim i As Long, ch As String * 1, level As Long
    Dim inQ As Boolean, q As String * 1, token As String
    token = "": level = 0: inQ = False

    For i = 1 To Len(inside)
        ch = Mid$(inside, i, 1)
        If inQ Then
            token = token & ch
            If ch = q Then inQ = False
        Else
            Select Case ch
                Case """", "'": inQ = True: q = ch: token = token & ch
                Case "(": level = level + 1: token = token & ch
                Case ")": If level > 0 Then level = level - 1: token = token & ch
                Case ","
                    If level = 0 Then
                        col.Add token
                        token = ""
                    Else
                        token = token & ch
                    End If
                Case Else
                    token = token & ch
            End Select
        End If
    Next
    If Len(Trim$(token)) > 0 Then col.Add token
    Set SplitArgs = col
End Function

'--- GetScalarValue ---
' 概要: {tbl.col} or リテラル を評価して文字列を返す（EXPR中の単項値用）
Private Function GetScalarValue(ByVal expr As String, ByVal baseTbl As String, ByVal baseRow As Long, _
                                ByVal myKey As String, ByVal processed As Boolean, _
                                Optional ByVal outColIndex As Long = -1) As String
    Dim s As String: s = Trim$(expr)
    If Len(s) = 0 Then Exit Function

    ' {tbl.col} トークンなら既存の解決系を通す
    If Left$(s, 1) = "{" And Right$(s, 1) = "}" Then
        Dim token As String: token = Mid$(s, 2, Len(s) - 2)
        If processed Then
            GetScalarValue = ResolveTokenProcessed(token, baseTbl, baseRow, myKey, outColIndex)
        Else
            GetScalarValue = ResolveTokenRaw(token, baseTbl, baseRow, myKey)
        End If
        Exit Function
    End If

    ' 文字列リテラル（"..." or '...'）
    If (Left$(s, 1) = """" And Right$(s, 1) = """") Or (Left$(s, 1) = "'" And Right$(s, 1) = "'") Then
        GetScalarValue = Mid$(s, 2, Len(s) - 2)
        Exit Function
    End If

    ' それ以外はそのまま（数値/識別子は文字列化）
    GetScalarValue = s
End Function

'======================
' 既存：SUM / IF / 数式 / テンプレ
' 変更点：LOOKUP(...) を追加
'======================

'--- EvalSUM（既存） ---
Private Function EvalSUM(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                         ByVal processed As Boolean, Optional outColIndex As Long = -1) As String
    Dim args As Collection: Set args = SplitArgs(Mid$(def, 5, Len(def) - 5)) ' "SUM("～")"
    Dim i As Long, total As Double
    For i = 1 To args.Count
        Dim v As String
        v = GetScalarValue(args(i), baseTbl, baseRow, myKey, processed, outColIndex)
        total = total + NumVal(v)
    Next
    EvalSUM = CStr(total)
End Function

'--- EvaluateExpr（改修：LOOKUP対応を追加） ---
Public Function EvaluateExpr(def As String, baseTbl As String, baseRow As Long, myKey As String, _
                             ByVal processed As Boolean, Optional outColIndex As Long = -1) As Variant
    Dim lines As Collection: Set lines = SplitExprToLines(def)
    Dim i As Long, one As String, res As String, acc As String

    For i = 1 To lines.Count
        one = Trim$(lines(i))
        If one = "" Then GoTo CONT

        If HasIFSyntax(one) Then
            res = EvalIFLine(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        ElseIf InStr(one, """") > 0 Or InStr(one, "'") > 0 Then
            ' テンプレート（"..."内に{tbl.col}）
            res = ApplyTemplate(one, baseTbl, baseRow, myKey, processed, outColIndex)
            If Len(res) > 0 Then If acc = "" Then acc = res Else acc = acc & vbLf & res

        Else
            Dim up As String: up = UCase$(one)

            ' === 追加: LOOKUP(...) ===
            ' 形式: LOOKUP(tbl, find_col, find_value_expr, ret_col)
            If Left$(up, 7) = "LOOKUP(" And Right$(up, 1) = ")" Then
                Dim inside As String, args As Collection
                inside = Mid$(one, 8, Len(one) - 8) ' "LOOKUP(" の後～")"直前
                Set args = SplitArgs(inside)
                If args.Count >= 4 Then
                    Dim tbl As String, fcol As String, vexpr As String, rcol As String
                    Dim fval As String
                    tbl  = Trim$(args(1))
                    fcol = Trim$(args(2))
                    vexpr= Trim$(args(3))
                    rcol = Trim$(args(4))
                    ' find_value_expr は {tbl.col} またはリテラルを許可
                    fval = GetScalarValue(vexpr, baseTbl, baseRow, myKey, processed, outColIndex)
                    res = GetValueByColumn(tbl, fcol, fval, rcol)
                Else
                    res = ""
                End If

            ' === 既存: SUM(...) ===
            ElseIf Left$(up, 4) = "SUM(" And Right$(up, 1) = ")" Then
                res = EvalSUM(one, baseTbl, baseRow, myKey, processed, outColIndex)

            Else
                Dim expr As String
                If processed Then
                    expr = ReplaceTokensProcessedAsNumber(one, baseTbl, baseRow, myKey, outColIndex)
                Else
                    expr = ReplaceTokensWithRaw(one, baseTbl, baseRow, myKey)
                End If

                ' Excel Evaluate → 失敗時 SafeEval
                Dim v As Variant
                On Error Resume Next
                v = Application.Evaluate("=" & expr)
                On Error GoTo 0
                If IsError(v) Or VarType(v) = vbError Or IsEmpty(v) Then
                    res = CStr(SafeEval(expr))
                Else
                    res = CStr(v)
                End If
            End If

            If acc = "" Then acc = res Else acc = acc & vbLf & res
        End If
CONT:
    Next

    If processed And outColIndex > 0 Then
        EvaluateExpr = FinalizeByType(acc, Map_DataType(outColIndex))
    Else
        EvaluateExpr = acc
    End If
End Function

'======================
' 以降、既存の関数群（抜粋コメント）
'======================
' ReplaceTokensWithRaw / ReplaceTokensProcessedAsNumber / ApplyTemplate
' ResolveTokenRaw / ResolveTokenProcessed / GetValueFromTableMulti
' BuildJoinedRaw / CollectKeyColIndexesForBase / ほか
' ※ 上記は元の実装をそのまま残してください（本ファイルでは LOOKUP 追加のみ）
