Option Explicit
'============================================================
' modJoinAndEval
' 概要: JOIN/評価のユーティリティ（JoinKey対応の索引＆パース含む）
'============================================================

'=== 索引キャッシュ（参照テーブル＋キー列セット → "v1|v2" → 行番号） ===
Private joinIndexCache As Object

Public Function GetOrBuildJoinIndex(ByVal tableName As String, ByVal keyCols As Variant) As Object
    Dim cacheKey As String, i As Long
    If joinIndexCache Is Nothing Then Set joinIndexCache = CreateObject("Scripting.Dictionary")
    cacheKey = tableName
    For i = LBound(keyCols) To UBound(keyCols)
        cacheKey = cacheKey & "|" & CStr(keyCols(i))
    Next
    If joinIndexCache.Exists(cacheKey) Then
        Set GetOrBuildJoinIndex = joinIndexCache(cacheKey)
        Exit Function
    End If

    Dim t As Variant, hdrIx As Object, r As Long, j As Long, comp As String
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    If TableData Is Nothing Then Set GetOrBuildJoinIndex = dict: Exit Function
    If Not TableData.Exists(tableName) Then Set GetOrBuildJoinIndex = dict: Exit Function

    t = TableData(tableName) ' 1-based, header
    Set hdrIx = CreateObject("Scripting.Dictionary")
    For j = 1 To UBound(t, 2)
        hdrIx(CStr(t(1, j))) = j
    Next

    Dim idx() As Long
    ReDim idx(LBound(keyCols) To UBound(keyCols))
    For j = LBound(keyCols) To UBound(keyCols)
        If Not hdrIx.Exists(CStr(keyCols(j))) Then Set GetOrBuildJoinIndex = dict: Exit Function
        idx(j) = CLng(hdrIx(CStr(keyCols(j))))
    Next

    For r = 2 To UBound(t, 1)
        comp = ""
        For j = LBound(idx) To UBound(idx)
            If Len(comp) > 0 Then comp = comp & "|"
            comp = comp & CStr(t(r, idx(j)))
        Next
        If Not dict.Exists(comp) Then dict.Add comp, r
    Next

    joinIndexCache(cacheKey) = dict
    Set GetOrBuildJoinIndex = dict
End Function

'=== JoinKey パース（例: "UserAccountMap:old_id=作成者CD,sub=部署CD"） ===
Public Type TJoinSpec
    tableName As String
    refKeyCols As Variant  ' 参照側キー列名配列
    baseCols As Variant    ' ベース側列名配列
End Type

Public Function ParseJoinSpec(ByVal spec As String) As TJoinSpec
    Dim js As TJoinSpec, p As Long, leftPart As String, rightPart As String
    Dim tokens As Variant, i As Long
    p = InStr(1, spec, ":", vbTextCompare)
    If p = 0 Then ParseJoinSpec = js: Exit Function
    leftPart = Trim$(Left$(spec, p - 1))
    rightPart = Trim$(Mid$(spec, p + 1))
    If Len(leftPart) = 0 Or Len(rightPart) = 0 Then ParseJoinSpec = js: Exit Function
    js.tableName = leftPart

    tokens = Split(rightPart, ",")
    ReDim js.refKeyCols(LBound(tokens) To UBound(tokens))
    ReDim js.baseCols(LBound(tokens) To UBound(tokens))

    For i = LBound(tokens) To UBound(tokens)
        Dim kv As Variant, k As String, v As String, q As Long
        kv = Split(Trim$(tokens(i)), "=")
        If UBound(kv) = 1 Then
            k = Trim$(kv(0))
            v = Trim$(kv(1))
            q = InStrRev(v, ".")
            If q > 0 Then v = Mid$(v, q + 1) ' "tbl.col" → "col"
            js.refKeyCols(i) = k
            js.baseCols(i) = v
        End If
    Next
    ParseJoinSpec = js
End Function

'=== ヘッダ名で列番号を探す ===
Public Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long, target As String
    target = Norm(colName)
    For c = 1 To UBound(arr, 2)
        If Norm(CStr(arr(1, c))) = target Then
            FindColumnIndex = c: Exit Function
        End If
    Next
    FindColumnIndex = 0
End Function

'=== 文字列正規化（BOM除去＋Trim） ===
Public Function Norm(ByVal s As String) As String
    If Len(s) = 0 Then Norm = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "")
    Norm = Trim$(s)
End Function

'=== ベースのキー列（Map_IsKey = True の出力列）→ベース配列の列番号に変換 ===
Public Function CollectKeyColIndexesForBase(baseArr As Variant, baseTbl As String) As Variant
    Dim tIdx As Long, i As Long, kc As Long
    tIdx = IndexOfTable(Map_TblNames, baseTbl)
    If tIdx < LBound(Map_TblNames) Then CollectKeyColIndexesForBase = Array(): Exit Function

    Dim names As Collection
    kc = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then If names.Count > 0 Then kc = kc + 1
        End If
    Next
    If kc = 0 Then CollectKeyColIndexesForBase = Array(): Exit Function

    Dim idx() As Long, cur As Long
    ReDim idx(1 To kc): cur = 0
    For i = LBound(Map_OutCols) To UBound(Map_OutCols)
        If Map_IsKey(i) Then
            Set names = SafeGetSrcColNames(i, tIdx)
            If Not names Is Nothing Then
                Dim picked As Long: picked = 0
                Dim j As Long, nm As String, ci As Long
                For j = 1 To names.Count
                    nm = names(j)
                    If IsNumeric(nm) Then
                        ci = CLng(nm)
                    Else
                        ci = FindColumnIndex(baseArr, nm)
                    End If
                    If ci > 0 Then picked = ci: Exit For
                Next
                If picked > 0 Then
                    cur = cur + 1
                    idx(cur) = picked
                End If
            End If
        End If
    Next
    CollectKeyColIndexesForBase = idx
End Function

'=== Map_TblNames の中から名前一致のインデックス ===
Public Function IndexOfTable(tblNames() As String, name As String) As Long
    Dim i As Long
    For i = LBound(tblNames) To UBound(tblNames)
        If tblNames(i) = name Then IndexOfTable = i: Exit Function
    Next
    IndexOfTable = LBound(tblNames) - 1
End Function

'=== Map_SrcCols から列名を安全に取得 ===
Public Function SafeGetSrcColNames(i As Long, tIdx As Long) As Collection
    Dim col As New Collection
    Dim raw As String
    raw = SafeGetSrcColName(i, tIdx)
    If Len(raw) = 0 Then
        Set SafeGetSrcColNames = col: Exit Function
    End If

    Dim s As String: s = Replace$(Replace$(raw, vbCrLf, vbLf), vbCr, vbLf)
    s = Replace$(s, "|", vbLf)
    Dim arr() As String, k As Long, one As String
    arr = Split(s, vbLf)
    For k = LBound(arr) To UBound(arr)
        one = Norm(arr(k))
        If Len(one) > 0 Then col.Add one
    Next
    Set SafeGetSrcColNames = col
End Function

Private Function SafeGetSrcColName(i As Long, tIdx As Long) As String
    On Error GoTo FAIL
    Dim lb1 As Long, ub1 As Long, lb2 As Long, ub2 As Long
    lb1 = LBound(Map_SrcCols, 1): ub1 = UBound(Map_SrcCols, 1)
    lb2 = LBound(Map_SrcCols, 2): ub2 = UBound(Map_SrcCols, 2)

    Dim tAdj As Long
    If lb2 = 1 And LBound(Map_TblNames) = 0 Then
        tAdj = tIdx + 1
    Else
        tAdj = tIdx
    End If
    If i < lb1 Or i > ub1 Or tAdj < lb2 Or tAdj > ub2 Then GoTo FAIL

    Dim v As Variant: v = Map_SrcCols(i, tAdj)
    If IsError(v) Or IsNull(v) Or IsArray(v) Then GoTo FAIL
    SafeGetSrcColName = Trim$(CStr(v))
    Exit Function
FAIL:
    SafeGetSrcColName = ""
End Function

'=== 複合キー作成 ===
Public Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String: s = ""
    If (Not Not keyColIdx) <> 0 Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
        Next
    End If
    If Len(s) > 0 Then s = Mid$(s, 2)
    BuildKeyFromRow = s
End Function

'=== FindColumnIndex 等を必要とする他モジュールから呼ばれることを想定（Publicにしておく） ===

'=== ここまで: modJoinAndEval ===
