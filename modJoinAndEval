Option Explicit
'============================================================
' modJoinAndEval（JoinKey対応の索引＆パース・重複定義なし）
'============================================================

'=== 索引キャッシュ（参照テーブル＋キー列セット → "v1|v2" → 行番号） ===
Private joinIndexCache As Object

Public Function GetOrBuildJoinIndex(ByVal tableName As String, ByVal keyCols As Variant) As Object
    Dim cacheKey As String, i As Long
    If joinIndexCache Is Nothing Then Set joinIndexCache = CreateObject("Scripting.Dictionary")
    cacheKey = tableName
    For i = LBound(keyCols) To UBound(keyCols)
        cacheKey = cacheKey & "|" & CStr(keyCols(i))
    Next
    If joinIndexCache.Exists(cacheKey) Then
        Set GetOrBuildJoinIndex = joinIndexCache(cacheKey): Exit Function
    End If

    Dim t As Variant, hdrIx As Object, r As Long, j As Long, comp As String
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    If TableData Is Nothing Then Set GetOrBuildJoinIndex = dict: Exit Function
    If Not TableData.Exists(tableName) Then Set GetOrBuildJoinIndex = dict: Exit Function

    t = TableData(tableName) ' 1-based, header
    Set hdrIx = CreateObject("Scripting.Dictionary")
    For j = 1 To UBound(t, 2)
        hdrIx(CStr(t(1, j))) = j
    Next

    Dim idx() As Long
    ReDim idx(LBound(keyCols) To UBound(keyCols))
    For j = LBound(keyCols) To UBound(keyCols)
        If Not hdrIx.Exists(CStr(keyCols(j))) Then Set GetOrBuildJoinIndex = dict: Exit Function
        idx(j) = CLng(hdrIx(CStr(keyCols(j))))
    Next

    For r = 2 To UBound(t, 1)
        comp = ""
        For j = LBound(idx) To UBound(idx)
            If Len(comp) > 0 Then comp = comp & "|"
            comp = comp & CStr(t(r, idx(j)))
        Next
        If Not dict.Exists(comp) Then dict.Add comp, r
    Next

    joinIndexCache(cacheKey) = dict
    Set GetOrBuildJoinIndex = dict
End Function

'=== JoinKey パース（例: "UserAccountMap:old_id=作成者CD,sub=部署CD"） ===
Public Type TJoinSpec
    tableName As String
    refKeyCols As Variant  ' 参照側キー列名配列
    baseCols As Variant    ' ベース側列名配列
End Type

Public Function ParseJoinSpec(ByVal spec As String) As TJoinSpec
    Dim js As TJoinSpec, p As Long, leftPart As String, rightPart As String
    Dim tokens As Variant, i As Long
    p = InStr(1, spec, ":", vbTextCompare)
    If p = 0 Then ParseJoinSpec = js: Exit Function
    leftPart = Trim$(Left$(spec, p - 1))
    rightPart = Trim$(Mid$(spec, p + 1))
    If Len(leftPart) = 0 Or Len(rightPart) = 0 Then ParseJoinSpec = js: Exit Function
    js.tableName = leftPart

    tokens = Split(rightPart, ",")
    ReDim js.refKeyCols(LBound(tokens) To UBound(tokens))
    ReDim js.baseCols(LBound(tokens) To UBound(tokens))

    For i = LBound(tokens) To UBound(tokens)
        Dim kv As Variant, k As String, v As String, q As Long
        kv = Split(Trim$(tokens(i)), "=")
        If UBound(kv) = 1 Then
            k = Trim$(kv(0))
            v = Trim$(kv(1))
            q = InStrRev(v, ".")
            If q > 0 Then v = Mid$(v, q + 1) ' "tbl.col" → "col"
            js.refKeyCols(i) = k
            js.baseCols(i) = v
        End If
    Next
    ParseJoinSpec = js
End Function

'=== 小ヘルパ ===
Public Function FindColumnIndex(arr As Variant, colName As String) As Long
    Dim c As Long, target As String
    target = Norm(colName)
    For c = 1 To UBound(arr, 2)
        If Norm(CStr(arr(1, c))) = target Then
            FindColumnIndex = c: Exit Function
        End If
    Next
    FindColumnIndex = 0
End Function

Public Function Norm(ByVal s As String) As String
    If Len(s) = 0 Then Norm = "": Exit Function
    s = Replace$(s, ChrW(&HFEFF), "")
    Norm = Trim$(s)
End Function

Public Function BuildKeyFromRow(arr As Variant, rowIdx As Long, keyColIdx() As Long) As String
    Dim i As Long, s As String: s = ""
    If (Not Not keyColIdx) <> 0 Then
        For i = LBound(keyColIdx) To UBound(keyColIdx)
            If keyColIdx(i) > 0 Then s = s & "|" & CStr(arr(rowIdx, keyColIdx(i)))
        Next
    End If
    If Len(s) > 0 Then s = Mid$(s, 2)
    BuildKeyFromRow = s
End Function
